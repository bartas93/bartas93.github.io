"use strict";(self.webpackChunklearning_notes=self.webpackChunklearning_notes||[]).push([[8586],{7426:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>a});var t=i(85893),c=i(11151);const r={sidebar_label:"Reconciliation",description:"How does React reconcile components?"},o="React Reconciliation Algorithm",l={id:"Web/React/reconciliation",title:"React Reconciliation Algorithm",description:"How does React reconcile components?",source:"@site/docs/Web/React/02-reconciliation.md",sourceDirName:"Web/React",slug:"/Web/React/reconciliation",permalink:"/docs/Web/React/reconciliation",draft:!1,unlisted:!1,editUrl:"https://github.com/xiaohai-huang/learning-notes/tree/master/docs/Web/React/02-reconciliation.md",tags:[],version:"current",lastUpdatedBy:"xiaohai-huang",lastUpdatedAt:1668140473,formattedLastUpdatedAt:"11 Nov 2022",sidebarPosition:2,frontMatter:{sidebar_label:"Reconciliation",description:"How does React reconcile components?"},sidebar:"notesSidebar",previous:{title:"Hook",permalink:"/docs/Web/React/hook"},next:{title:"Browser",permalink:"/docs/Web/Browser/"}},s={},a=[{value:"Two Assumptions",id:"two-assumptions",level:2},{value:"<code>ChildReconciler</code>",id:"childreconciler",level:2},{value:"<code>reconcileSingleElement</code>",id:"reconcilesingleelement",level:3},{value:"<code>reconcileChildrenArray</code>",id:"reconcilechildrenarray",level:3},{value:"References",id:"references",level:2}];function d(e){const n=Object.assign({h1:"h1",p:"p",strong:"strong",code:"code",a:"a",pre:"pre",ul:"ul",li:"li",blockquote:"blockquote",h2:"h2",ol:"ol",admonition:"admonition",h3:"h3"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"react-reconciliation-algorithm",children:"React Reconciliation Algorithm"}),"\n",(0,t.jsx)(n.p,{children:"Because React is declarative and we don't have to worry about exactly what changes on every update. For example, if we reorder a list item within a list, React will iterate over the old list and the new list and figure out how to efficiently update the UI to match the most recent list."}),"\n",(0,t.jsxs)(n.p,{children:["Those efficient updates are achieved by the ",(0,t.jsx)(n.strong,{children:"reconciliation"})," algorithm. The reconciliation algorithm always starts from the ",(0,t.jsx)(n.code,{children:"FiberRootNode"})," fiber using one of the following ",(0,t.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1663",children:"functions"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const exitStatus = shouldTimeSlice\n  ? renderRootConcurrent(root, lanes)\n  : renderRootSync(root, lanes);\n"})}),"\n",(0,t.jsx)(n.p,{children:"However, React will attempt to bail out (skip) fibers which meet the following conditions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"oldProps === newProps"})," && ",(0,t.jsx)(n.code,{children:"workInProgress.type === current.type"})]}),"\n",(0,t.jsx)(n.li,{children:"no pending updates and context."}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3685",children:"details of bail out conditions"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If the above conditions are all satisfied, React will invoke ",(0,t.jsx)(n.code,{children:"bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)"})," on the current fiber and ",(0,t.jsx)(n.code,{children:"beginWork"})," on its child."]}),"\n",(0,t.jsxs)(n.p,{children:["This significantly improves the performance of the app. For example, if you call ",(0,t.jsx)(n.code,{children:"setState"})," deep in the components tree, React will start from the top but quickly skip over the parents until it gets to the component that had its ",(0,t.jsx)(n.code,{children:"setState"})," called."]}),"\n",(0,t.jsx)(n.h2,{id:"two-assumptions",children:"Two Assumptions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Two elements of different types will produce different trees."}),"\n",(0,t.jsxs)(n.li,{children:["The developer can hint at which child elements may be stable across different renders with a ",(0,t.jsx)(n.code,{children:"key"})," prop."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["By default, every React Element will have ",(0,t.jsx)(n.code,{children:"key"})," set to ",(0,t.jsx)(n.code,{children:"null"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"childreconciler",children:(0,t.jsx)(n.code,{children:"ChildReconciler"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="ReactChildFiber.new.js"',children:"function ChildReconciler(shouldTrackSideEffects) {}\nconst reconcileChildFibers = ChildReconciler(true);\nconst mountChildFibers = ChildReconciler(false);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reconcilesingleelement",children:(0,t.jsx)(n.code,{children:"reconcileSingleElement"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function reconcileSingleElement(\n  returnFiber,\n  currentFirstChild,\n  element,\n  lanes\n) {}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If this is a new element, mark the fiber with ",(0,t.jsx)(n.code,{children:"Update"})," flag."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"reconcilechildrenarray",children:(0,t.jsx)(n.code,{children:"reconcileChildrenArray"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function reconcileChildrenArray(\n  returnFiber,\n  currentFirstChild,\n  newChildren,\n  lanes\n) {}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This determines if the orders, insertions, deletions of elements in the children array."}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js",children:"ReactChildFiber.new.js"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://reactjs.org/docs/reconciliation.html",children:"Reconciliation | React docs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react",children:"Inside Fiber: in-depth overview of the new reconciliation algorithm in React"})}),"\n"]})]})}const h=function(e={}){const{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(d,e)})):d(e)}},11151:(e,n,i)=>{i.d(n,{Zo:()=>l,ah:()=>r});var t=i(67294);const c=t.createContext({});function r(e){const n=t.useContext(c);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const o={};function l({components:e,children:n,disableParentContext:i}){let l;return l=i?"function"==typeof e?e({}):e||o:r(e),t.createElement(c.Provider,{value:l},n)}}}]);