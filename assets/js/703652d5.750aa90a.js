"use strict";(self.webpackChunklearning_notes=self.webpackChunklearning_notes||[]).push([[5411],{83038:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var o=t(85893),r=t(11151);const s={sidebar_label:"Hook",description:"The data fields used by react hooks. And how react hooks handle on mount and on update."},c="React Hook",a={id:"Web/React/hook",title:"React Hook",description:"The data fields used by react hooks. And how react hooks handle on mount and on update.",source:"@site/docs/Web/React/01-hook.md",sourceDirName:"Web/React",slug:"/Web/React/hook",permalink:"/docs/Web/React/hook",draft:!1,unlisted:!1,editUrl:"https://github.com/xiaohai-huang/learning-notes/tree/master/docs/Web/React/01-hook.md",tags:[],version:"current",lastUpdatedBy:"xiaohai-huang",lastUpdatedAt:1695920464,formattedLastUpdatedAt:"28 Sept 2023",sidebarPosition:1,frontMatter:{sidebar_label:"Hook",description:"The data fields used by react hooks. And how react hooks handle on mount and on update."},sidebar:"notesSidebar",previous:{title:"Fiber",permalink:"/docs/Web/React/fiber"},next:{title:"Reconciliation",permalink:"/docs/Web/React/reconciliation"}},i={},d=[{value:"Source Code",id:"source-code",level:2},{value:"types",id:"types",level:3},{value:"<code>HookFlags</code>",id:"hookflags",level:3},{value:"<code>renderWithHooks</code>",id:"renderwithhooks",level:3},{value:"<code>Dispatcher</code>",id:"dispatcher",level:3},{value:"Mount",id:"mount",level:2},{value:"<code>mountState</code>",id:"mountstate",level:3},{value:"<code>mountWorkInProgressHook</code>",id:"mountworkinprogresshook",level:3},{value:"Update",id:"update",level:2},{value:"<code>dispatchSetState</code>",id:"dispatchsetstate",level:3},{value:"Concurrent Update Queue",id:"concurrent-update-queue",level:3}];function l(e){const n=Object.assign({h1:"h1",p:"p",a:"a",code:"code",h2:"h2",ul:"ul",li:"li",h3:"h3",pre:"pre",blockquote:"blockquote",strong:"strong",ol:"ol",admonition:"admonition",em:"em",img:"img"},(0,r.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"react-hook",children:"React Hook"}),"\n",(0,o.jsxs)(n.p,{children:["Hooks are stored as a linked list on the ",(0,o.jsx)(n.a,{href:"/docs/Web/React/fiber#fibernode",children:"fiber"}),"'s ",(0,o.jsx)(n.code,{children:"memoizedState"})," field."]}),"\n",(0,o.jsx)(n.h2,{id:"source-code",children:"Source Code"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js",children:"ReactFiberHooks.new.js"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactHookEffectTags.js",children:"ReactHookEffectTags.js"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"types",children:"types"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="ReactFiberHooks.new.js"',children:"type Update<S, A> = {|\n  lane: Lane,\n  action: A,\n  hasEagerState: boolean,\n  eagerState: S | null,\n  next: Update<S, A>,\n|};\n\ntype UpdateQueue<S, A> = {|\n  pending: Update<S, A> | null,\n  lanes: Lanes,\n  dispatch: (A => mixed) | null,\n  lastRenderedReducer: ((S, A) => S) | null,\n  lastRenderedState: S | null,\n|};\n\ntype Hook = {|\n  memoizedState: any,\n  baseState: any,\n  baseQueue: Update<any, any> | null,\n  queue: any,\n  next: Hook | null,\n|};\n\ntype Effect = {|\n  tag: HookFlags,\n  create: () => (() => void) | void,\n  destroy: (() => void) | void,\n  deps: Array<mixed> | null,\n  next: Effect,\n|};\n\ntype FunctionComponentUpdateQueue = {|\n  lastEffect: Effect | null,\n  stores: Array<StoreConsistencyCheck<any>> | null,\n|};\n\ntype BasicStateAction<S> = (S => S) | S;\n\ntype Dispatch<A> = A => void;\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["source code: ",(0,o.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js",children:"react/packages/react-reconciler/src/ReactFiberHooks.new.js"})]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"hookflags",children:(0,o.jsx)(n.code,{children:"HookFlags"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"HookFlags"}),", ",(0,o.jsx)(n.code,{children:"HookEffectTags"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="ReactHookEffectTags.js"',children:"export type HookFlags = number;\n\nexport const NoFlags = /*   */ 0b0000;\n\n// Represents whether effect should fire.\nexport const HasEffect = /* */ 0b0001;\n\n// Represents the phase in which the effect (not the clean-up) fires.\nexport const Insertion = /*  */ 0b0010;\nexport const Layout = /*    */ 0b0100;\nexport const Passive = /*   */ 0b1000;\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["source code: ",(0,o.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactHookEffectTags.js",children:"react/packages/react-reconciler/src/ReactHookEffectTags.js"})]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"renderwithhooks",children:(0,o.jsx)(n.code,{children:"renderWithHooks"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="ReactFiberHooks.new.js"',children:"// The current hook list is the list that belongs to the current fiber.\nlet currentHook: Hook | null = null;\n// The work-in-progress hook list is a new list\n// that will be added to the work-in progress fiber.\nlet workInProgressHook: Hook | null = null;\n\nfunction renderWithHooks<Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n  nextRenderLanes: Lanes\n): any {\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes;\n\n  const isMount = current === null || current.memoizedState === null;\n  ReactCurrentDispatcher.current = isMount\n    ? HooksDispatcherOnMount\n    : HooksDispatcherOnUpdate;\n\n  const children = Component(props, secondArg);\n\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  return children;\n}\n// renderWithHooks(current, workInProgress, Component)\n//      updateFunctionComponent(current, workInProgress, Component)\n//          beginWork(current, workInProgress)\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["source code: ",(0,o.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L374",children:"react/packages/react-reconciler/src/ReactFiberHooks.new.js"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"renderWithHooks"})," renders a function component. Before calling the ",(0,o.jsx)(n.code,{children:"Component(props)"})," function, it needs to determine which ",(0,o.jsx)(n.code,{children:"Dispatcher"})," needs to be used depending on whether the component is during ",(0,o.jsx)(n.strong,{children:"mount"})," or ",(0,o.jsx)(n.strong,{children:"update"}),". ",(0,o.jsx)(n.code,{children:"ReactCurrentDispatcher.current"})," is determined by ",(0,o.jsx)(n.code,{children:"current === null || current.memoizedState === null"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"dispatcher",children:(0,o.jsx)(n.code,{children:"Dispatcher"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const HooksDispatcherOnMount: Dispatcher = {\n  readContext,\n  useCallback: mountCallback,\n  useContext: readContext,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  ...\n}\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  ...\n}\n\nReactCurrentDispatcher.current = isMount\n    ? HooksDispatcherOnMount\n    : HooksDispatcherOnUpdate;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"mount",children:"Mount"}),"\n",(0,o.jsxs)(n.p,{children:["Below is an example component ",(0,o.jsx)(n.code,{children:"Counter"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:"{2-3}",children:'function Counter() {\n  const [num, setNum] = React.useState(6);\n  const [enabled, setEnabled] = React.useState(false);\n\n  return (\n    <div>\n      <p>The number is: {num}</p>\n      <button>{enabled ? "ON" : "OFF"}</button>\n    </div>\n  );\n}\n// <Counter />\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="React.useState(initialState)" {4}',children:"function useState(initialState) {\n  // HooksDispatcherOnMount | HooksDispatcherOnUpdate\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"mountstate",children:(0,o.jsx)(n.code,{children:"mountState"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="mountState(initialState)"',children:'const HooksDispatcherOnMount: Dispatcher = {\n  ...,\n  useState: mountState,\n  ...\n};\n\nfunction mountState<S>(\n  initialState: (() => S) | S\n): [S, Dispatch<BasicStateAction<S>>] {\n  // Create a hook for the component\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === "function") {\n    // $FlowFixMe: Flow doesn\'t like mixed types\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue<S, BasicStateAction<S>> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState,\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch<BasicStateAction<S>> = queue.dispatch =\n    dispatchSetState.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Creates a ",(0,o.jsx)(n.code,{children:"hook"})," object and populates"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"hook.memoizedState"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"hook.baseState"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"hook.queue"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Creates an ",(0,o.jsx)(n.code,{children:"UpdateQueue"})," for the ",(0,o.jsx)(n.code,{children:"hook"})," object and populates the queue with the dispatch function (",(0,o.jsx)(n.code,{children:"dispatchSetState"}),")."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"queue.dispatch"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Returns the ",(0,o.jsx)(n.code,{children:"initialState"})," and ",(0,o.jsx)(n.code,{children:"dispatchSetState"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["Why ",(0,o.jsx)(n.code,{children:"setState"})," is ",(0,o.jsx)(n.em,{children:"stable"})," across different renders?"]}),(0,o.jsxs)(n.p,{children:["During an ",(0,o.jsx)(n.strong,{children:"update"}),", ",(0,o.jsx)(n.code,{children:"queue.dispatch"})," will be ",(0,o.jsx)(n.strong,{children:"reused"})," in ",(0,o.jsx)(n.code,{children:"updateState -> updateReducer"})," as the dispatch function."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function updateReducer(reducer) {\n  // omit irrelevant code\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  const dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n"})})]}),"\n",(0,o.jsx)(n.h3,{id:"mountworkinprogresshook",children:(0,o.jsx)(n.code,{children:"mountWorkInProgressHook"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Instantiate a hook for the component and\n// stores the hook in `memoizedState` field of the component's fiber.\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"mountWorkInProgressHook"})," stores the hooks of a component as a linked list on its ",(0,o.jsx)(n.code,{children:"memoizedState"})," field."]}),"\n",(0,o.jsx)(n.h2,{id:"update",children:"Update"}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsxs)(n.p,{children:["There are a few different ways to tell React to queue a ",(0,o.jsx)(n.strong,{children:"re-render"}),":"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Function components:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"useState"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"useReducer"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Class components:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"this.setState()"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"this.forceUpdate()"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Other:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Calling the ReactDOM top-level ",(0,o.jsx)(n.code,{children:"root.render(<App />)"})," method ",(0,o.jsx)(n.strong,{children:"again"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Updates triggered from the ",(0,o.jsx)(n.code,{children:"useSyncExternalStore"})," hook."]}),"\n"]}),"\n"]}),"\n"]}),(0,o.jsx)("cite",{children:(0,o.jsx)("a",{href:"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#queuing-renders",children:"How Does React Handle Renders?"})})]}),"\n",(0,o.jsx)(n.h3,{id:"dispatchsetstate",children:(0,o.jsx)(n.code,{children:"dispatchSetState"})}),"\n",(0,o.jsxs)(n.p,{children:["An update can be triggered by ",(0,o.jsx)(n.code,{children:"setState"})," | ",(0,o.jsx)(n.code,{children:"dispatchSetState"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// the arguments fiber and queue are fixed by `.bind`\n// action is the value passed by setState\nfunction dispatchSetState<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A\n) {\n  const lane = requestUpdateLane(fiber); // if the function is invoked by click event, lane = 1\n\n  const update: Update<S, A> = {\n    lane,\n    action, // value passed by setState, either an updater or a new state value\n    hasEagerState: false,\n    eagerState: null,\n    next: null,\n  };\n\n  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n  if (root !== null) {\n    var eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n    entangleTransitionUpdate(root, queue, lane);\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Firstly, ",(0,o.jsx)(n.code,{children:"dispatchSetState"})," creates an ",(0,o.jsx)(n.code,{children:"update"})," and enqueue it to the ",(0,o.jsx)(n.code,{children:"concurrentQueues"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Concurrent queues",src:t(53960).Z+"",width:"561",height:"217"})}),"\n",(0,o.jsxs)(n.p,{children:["Secondly, ",(0,o.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," triggers a re-render by scheduling a task using ",(0,o.jsx)(n.code,{children:"ensureRootIsScheduled(root, eventTime)"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["During an update, when evaluating the ",(0,o.jsx)(n.code,{children:"Counter()"})," function, the ",(0,o.jsx)(n.code,{children:"dispatcher"})," will be ",(0,o.jsx)(n.code,{children:"HooksDispatcherOnUpdate"})," which means that the ",(0,o.jsx)(n.code,{children:"useState"})," will call ",(0,o.jsx)(n.code,{children:"updateReducer(basicStateReducer, initialState);"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["And the ",(0,o.jsx)(n.strong,{children:"pending queue"})," of the ",(0,o.jsx)(n.code,{children:"hook"})," returned by ",(0,o.jsx)(n.code,{children:"updateWorkInProgressHook()"})," will have the new ",(0,o.jsx)(n.code,{children:"update"}),". We can then use the ",(0,o.jsx)(n.code,{children:"update"})," to compute the ",(0,o.jsx)(n.code,{children:"newState"})," and return it to the component i.e. ",(0,o.jsx)(n.code,{children:"[hook.memoizedState, dispatch]"})]}),"\n",(0,o.jsxs)(n.p,{children:["The source code of ",(0,o.jsx)(n.code,{children:"updateReducer"})," can be found ",(0,o.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L759",children:"here"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"concurrent-update-queue",children:"Concurrent Update Queue"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="ReactFiberConcurrentUpdates.new.js"',children:'import type {\n  UpdateQueue as HookQueue,\n  Update as HookUpdate,\n} from "./ReactFiberHooks.new";\n\ntype ConcurrentUpdate = {\n  next: ConcurrentUpdate;\n  lane: Lane;\n};\n\ntype ConcurrentQueue = {\n  pending: ConcurrentUpdate | null;\n};\nconst concurrentQueues: Array<any> = [];\n\nfunction enqueueConcurrentHookUpdate<S, A>(\n  fiber: Fiber,\n  queue: HookQueue<S, A>,\n  update: HookUpdate<S, A>,\n  lane: Lane\n): FiberRoot | null {\n  const concurrentQueue: ConcurrentQueue = queue;\n  const concurrentUpdate: ConcurrentUpdate = update;\n  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);\n  return getRootForUpdatedFiber(fiber); // FiberRootNode\n}\n\nfunction enqueueUpdate(\n  fiber: Fiber,\n  queue: ConcurrentQueue | null,\n  update: ConcurrentUpdate | null,\n  lane: Lane\n) {\n  // Don\'t update the `childLanes` on the return path yet. If we already in\n  // the middle of rendering, wait until after it has completed.\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\n  concurrentQueues[concurrentQueuesIndex++] = queue;\n  concurrentQueues[concurrentQueuesIndex++] = update;\n  concurrentQueues[concurrentQueuesIndex++] = lane;\n\n  concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane);\n\n  // The fiber\'s `lane` field is used in some places to check if any work is\n  // scheduled, to perform an eager bailout, so we need to update it immediately.\n  // TODO: We should probably move this to the "shared" queue instead.\n  fiber.lanes = mergeLanes(fiber.lanes, lane);\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["source code: ",(0,o.jsx)(n.a,{href:"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberConcurrentUpdates.new.js",children:"react/packages/react-reconciler/src/ReactFiberConcurrentUpdates.new.js"})]}),"\n"]}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsxs)(n.p,{children:["When do we make use of ",(0,o.jsx)(n.code,{children:"concurrentQueues"}),"?"]}),(0,o.jsxs)(n.p,{children:["Ans: We use ",(0,o.jsx)(n.code,{children:"finishQueueingConcurrentUpdates"})," to add the ",(0,o.jsx)(n.code,{children:"update"})," to the ",(0,o.jsx)(n.code,{children:"hook.queue"}),"'s pending list before the next render (in ",(0,o.jsx)(n.code,{children:"prepareFreshStack"})," for HostRoot)."]}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"finishQueueingConcurrentUpdates"})," also invokes ",(0,o.jsx)(n.code,{children:"markUpdateLaneFromFiberToRoot(fiber, update, lane)"})," which updates the source fiber's ",(0,o.jsx)(n.code,{children:"lanes"})," and walks the parent path to the root and update the ",(0,o.jsx)(n.code,{children:"childLanes"}),"."]}),(0,o.jsx)("cite",{children:(0,o.jsx)("a",{href:"https://github.com/facebook/react/pull/24663",children:'Refactor of interleaved ("concurrent") update queue #24663'})})]})]})}const u=function(e={}){const{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(l,e)})):l(e)}},53960:(e,n,t)=>{t.d(n,{Z:()=>o});const o=t.p+"assets/images/concurrentQueues-example-01-b998778af8daf70c913d6423ba92604b.png"},11151:(e,n,t)=>{t.d(n,{Zo:()=>a,ah:()=>s});var o=t(67294);const r=o.createContext({});function s(e){const n=o.useContext(r);return o.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const c={};function a({components:e,children:n,disableParentContext:t}){let a;return a=t?"function"==typeof e?e({}):e||c:s(e),o.createElement(r.Provider,{value:a},n)}}}]);