"use strict";(self.webpackChunkbj_blog=self.webpackChunkbj_blog||[]).push([[5894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"jvm-memory-allocation-of-objects","metadata":{"permalink":"/blog/jvm-memory-allocation-of-objects","source":"@site/blog/2024-05-16-jvm-memory-allocation-of-objects.md","title":"Checking memory alocation of Objects - JOL library (Java Object Layout)","description":"In short","date":"2024-05-16T00:00:00.000Z","formattedDate":"May 16, 2024","tags":[{"label":"jvm","permalink":"/blog/tags/jvm"},{"label":"jol","permalink":"/blog/tags/jol"},{"label":"heap","permalink":"/blog/tags/heap"},{"label":"memory","permalink":"/blog/tags/memory"},{"label":"references","permalink":"/blog/tags/references"}],"readingTime":14.41,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"jvm-memory-allocation-of-objects","title":"Checking memory alocation of Objects - JOL library (Java Object Layout)","authors":"bjab","tags":["jvm","jol","heap","memory","references"]},"nextItem":{"title":"Regular expressions","permalink":"/blog/regular-expressions"}},"content":"## In short\\r\\n\\r\\n- Each object has memory overhead (from 12 to 16 bytes for metadata headers, references (4 bytes), memory for simple data type.\\r\\n- Processors (CPU) can be 32 bit (4 byte - supporting a maximum of 4 GB RAM) or 64 bit (8 byte). This means that the CPU downloads data from RAM in batches of 4 or 8 bytes at a time.\\r\\n- Padding - alignment to 8 bytes - i.e. objects occupy memory equal to a multiple of 8 bytes. This can be increased because it limits the use of the maximum heap to 32 GB.\\r\\n- The reference takes 4 bytes (32bit CPU or 64bit CPU with Compressed References (default)) or 8 bytes (64bit CPU).\\r\\n  - Maximum heap for Compressed References = 32 GB - use of bit shift by 3 places due to the fact that the 8 byte always has three zeros on the right side. (8 byte because it is aligned to 8 byte padding). Therefore we can use 32 GB heap instead of 4 GB.\\r\\n  - When we use a 64-bit CPU with Compressed References and increase the heap memory above 32 GB, we may have problems with the application and a significant increase in the heap occupied due to the change in reference memory from 4 bytes to 8 bytes for every object on our heap- e.g. a change from -Xmx31g to -Xmx33g may result in an increase in data seizure by 40% (depending on the data)\\r\\n\x3c!-- truncate --\x3e\\r\\n\\r\\n## Configuration\\r\\n\\r\\nTo check what the memory layout looks like, we will use the library:\\r\\n\\r\\n```xml\\r\\n<dependency>\\r\\n    <groupId>org.openjdk.jol</groupId>\\r\\n    <artifactId>jol-core</artifactId>\\r\\n    <version>0.10</version>\\r\\n</dependency>\\r\\n```\\r\\n\\r\\nJol is a toolbox for analyzing the layout of objects in the JVM. These tools use (to decode the actual layout of an object, its memory footprint (footprint) and references). Jol uses tools such as:\\r\\n\\r\\n- Unsafe\\r\\n- JVMTI\\r\\n- Serviceability Agent (SA)\\r\\n\\r\\n## Available methods\\r\\n\\r\\n### VM Details - `VM.current().details()` - Basic data related to our JVM\\r\\n\\r\\n```\\r\\n# Running 64-bit HotSpot VM.\\r\\n# Using compressed oop with 3-bit shift.\\r\\n# Using compressed klass with 3-bit shift.\\r\\n# WARNING | Compressed references base/shifts are guessed by the experiment!\\r\\n# WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\\r\\n# WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\\r\\n# Objects are 8 bytes aligned.\\r\\n# Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\\r\\n# Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\\r\\n```\\r\\n\\r\\n1. We run our program on the **64** bit version of **JVM \u2013 HotSpot**\\r\\n2. `Using compressed oop with 3-bit shift.` - [more info](#compressed-vs-uncompressed-references)\\r\\n3. `Using compressed classes with 3-bit shift.` - [more info](#compressed-vs-uncompressed-references)\\r\\n4. `Objects are 8 bytes aligned.` - Objects will be aligned to **8** bytes - this means that each object, even if it should occupy 20 bytes, will still occupy a multiple of 8 bytes, i.e. in this case 24 bytes. It always goes up to a multiple of 8 bytes.\\r\\n  1. Why?\\r\\n     Processors are 32 or 64 bit (32 bit CPU can use max 4 GB of memory) . That is, 4 or 8 rooms. Which means that they read (from the memory register via an external bus) 4 or 8 memory bytes at a time. The CPU does not fetch individual bits or entities. Delivers in parcels. This is because the CPU (e.g. 3GHz) is faster than the memory (400MHz). Taking advantage of the fact that the CPU is faster, we download data in batches. To make this data extraction easier (and faster), the JVM groups this data into 8 bytes for a 64-bit machine (which is most modern ones).\\r\\n  2. This can be changed with the JVM flag: `-XX:ObjectAlignmentInBytes=16` (Available values 8,16,32,64,128,256, otherwise the JVM will throw an error and will not run the application). A flag that will cause most objects to take up much more unused memory. The advantage of this solution is that we can then use 64 GB Heap with compressed references.\\r\\n5. Next, the type sizes in our JVM are shown\\r\\n  1. Object reference: 4 bytes - in this case, the Compressed References flag is enabled by default - therefore, in a 64-bit JVM, the reference takes up 4 bytes and not 8 bytes as it should. To make it take up 8 bytes, you need to run the JVM with the flag: *`XX:-UseCompressedOops`*\\r\\n\\r\\n     Additionally, remember that 4 bytes is 32 bits, i.e. 2^32 possible unique reference addresses to be saved - but we use 3 bit shifting\\r\\n\\r\\n  2. boolean and byte: 1 byte\\r\\n  3. short and char: 2bytes\\r\\n  4. int and float: 4 bytes\\r\\n  5. long and double 8 bytes\\r\\n\\r\\n### Types of memory usage determinations:\\r\\n\\r\\n- Shallow size - what the ClassLayout tells us\\r\\n- Deep size - what the footprint tells us\\r\\n- Retained size - what slows down the GC - e.g. these sizes are shown in heapdump\\r\\n\\r\\n![Size types](/blog/size-types.png)\\r\\n\\r\\nIn the above example - Retained size is the memory freed after removing the Triple reference - only Ai + Ci is freed and Bi is used by Pair. These additional references complicate the retained size. Retained size is always between shallow and deep size.\\r\\n\\r\\n### Class layout - ClassLayout (shallow size)\\r\\n\\r\\n`ClassLayout.parseClass(Basket.class).toPrintable(b1))`\\r\\n\\r\\nAll objects store data of a base type. They have their own additional memory overhead (metadata). The class layout shows us how many bytes the headers take up, how much simple type fields of a given class take up, how much references to other sub-objects take up (but it does not show how much memory a sub-object takes up). Additionally, it shows the offset (e.g. 4 bytes external) - that is, an offset to 8 bytes (padding)\\r\\n\\r\\n```java\\r\\n@Data\\r\\n@AllArgsConstructor\\r\\npublic class ExampleClass {\\r\\n    private int a;\\r\\n    private int b;\\r\\n}\\r\\n...\\r\\nExampleClass b1 = new ExampleClass(1232132, 123);\\r\\nSystem.out.println(ClassLayout.parseClass(ExampleClass.class).toPrintable(b1));\\r\\n```\\r\\n\\r\\n```\\r\\ncom.example.demo.ExampleClass object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 ed d3 b0 (00000001 11101101 11010011 10110000) (-1328288511)\\r\\n      4     4        (object header)                           6f 00 00 00 (01101111 00000000 00000000 00000000) (111)\\r\\n      8     4        (object header)                           78 f2 01 01 (01111000 11110010 00000001 00000001) (16904824)\\r\\n     12     4    int ExampleClass.a                            1232132\\r\\n     16     4    int ExampleClass.b                            123\\r\\n     20     4        (loss due to the next object alignment)\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\\r\\n```\\r\\n\\r\\n### **Metadata:**\\r\\n\\r\\n- headers:\\r\\n  - flags (0\u21924 bytes) (mark word) - store information about the state of the object. Among other things, the shape of the object, i.e. whether it is a class or an array and hash code and the number of GC survivals to be promoted to OldGeneration- 4 bytes\\r\\n  - lock (4\u21928 bytes) (mark word) - monitor that will be used for mutexes - 4 bytes\\r\\n\\r\\n      ```java\\r\\n      public class Lock {}\\r\\n      ...\\r\\n      Lock lock = new Lock();\\r\\n      /*\\r\\n      Lock object internals:\\r\\n       OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n            0     4        (object header)                           01 00 00 00 \\r\\n            4     4        (object header)                           00 **00** 00 00\\r\\n            8     4        (object header)                           85 23 02 f8\\r\\n           12     4        (loss due to the next object alignment)\\r\\n      Instance size: 16 bytes\\r\\n      */\\r\\n      synchronized (lock) {\\r\\n          System.out.println(ClassLayout.parseInstance(lock).toPrintable());\\r\\n      }\\r\\n      /*\\r\\n      Pierwszy header si\u0119 zmieni\u0142 poniewa\u017c przeliczony zosta\u0142 domy\u015blny hashCode()\\r\\n      Drugi header si\u0119 zmieni\u0142 ze wzgl\u0119du na lock!\\r\\n      Lock object internals:\\r\\n       OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n            0     4        (object header)                           f0 78 12 03\\r\\n            4     4        (object header)                           00 **70** 00 00\\r\\n            8     4        (object header)                           85 23 02 f8\\r\\n           12     4        (loss due to the next object alignment)\\r\\n      */\\r\\n      ```\\r\\n\\r\\n  - class (8\u219212 bytes) (class word) - pointer to the type in our case 4 bytes\\r\\n  - array size (4 byte) - the size of the array (this value is present only for array types) - in the example above it is not there\\r\\n\\r\\n  More information about headers: OOPs - Ordinary Object Pointers\\r\\n\\r\\n- Data\\r\\n  - class fields - the rest of the bytes in our example 2x4 bytes for int fields.\\r\\n- optional shift to 8 bytes (in in our case 4 bytes of offset)\\r\\n\\r\\n### Footprint (Deep size)\\r\\n\\r\\nIf we have any references to other objects in our analyzed object, the ClassLayout will only show an additional 4 bytes per reference (It will not take into account the content of the object we are referring to) - in this case, it is worth using FootPrint which will show how much memory the entire object takes up, including the object inside .\\r\\n\\r\\n```java\\r\\n@Data\\r\\n@AllArgsConstructor\\r\\npublic class ExampleClass {\\r\\n    private int a;\\r\\n    private int b;\\r\\n    private int c;\\r\\n    private InnerClass d;\\r\\n\\r\\n    @Data\\r\\n    @AllArgsConstructor\\r\\n    public static class InnerClass {\\r\\n        private int a;\\r\\n        private int b;\\r\\n    }\\r\\n}\\r\\n...\\r\\nExampleClass.InnerClass inner = new ExampleClass.InnerClass(10, 12);\\r\\nExampleClass b1 = new ExampleClass(1232132, 123,111, inner);\\r\\n\\r\\nSystem.out.println(GraphLayout.parseInstance(b1).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseClass(ExampleClass.class).toPrintable(b1));\\r\\nSystem.out.println(ClassLayout.parseClass(ExampleClass.InnerClass.class).toPrintable(inner));\\r\\n```\\r\\n\\r\\n```java\\r\\n### FOOTPRINT\\r\\ncom.example.demo.ExampleClass@6dde5c8cd footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        32        32   com.example.demo.ExampleClass\\r\\n         1        24        24   com.example.demo.ExampleClass$InnerClass\\r\\n         2                  56   (total)\\r\\n\\r\\n### CLASSLAYOUT\\r\\ncom.example.demo.ExampleClass object internals:\\r\\n OFFSET  SIZE                                       TYPE DESCRIPTION                               VALUE\\r\\n      0     4                                            (object header)                           01 8c 5c de (00000001 10001100 01011100 11011110) (-564360191)\\r\\n      4     4                                            (object header)                           6d 00 00 00 (01101101 00000000 00000000 00000000) (109)\\r\\n      8     4                                            (object header)                           a0 f4 01 01 (10100000 11110100 00000001 00000001) (16905376)\\r\\n     12     4                                        int ExampleClass.a                            1232132\\r\\n     16     4                                        int ExampleClass.b                            123\\r\\n     20     4                                        int ExampleClass.c                            111\\r\\n     24     4   com.example.demo.ExampleClass.InnerClass ExampleClass.d                            (object)\\r\\n     28     4                                            (loss due to the next object alignment)\\r\\nInstance size: 32 bytes\\r\\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\\r\\n\\r\\ncom.example.demo.ExampleClass$InnerClass object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 5b 3e 5b (00000001 01011011 00111110 01011011) (1530813185)\\r\\n      4     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      8     4        (object header)                           78 f2 01 01 (01111000 11110010 00000001 00000001) (16904824)\\r\\n     12     4    int InnerClass.a                              10\\r\\n     16     4    int InnerClass.b                              12\\r\\n     20     4        (loss due to the next object alignment)\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\\r\\n```\\r\\n\\r\\nAbove we have a comparison of Footprint and ClassLayout. In Footprint we see exactly how many bytes the object and its sub-objects occupy (56 bytes). And in ClassLayout we only see an overview of a given class without any sub-objects (32 bytes and 24 bytes).\\r\\n\\r\\nLet\'s break down the footprint to make it even clearer:\\r\\n\\r\\n56 bytes consists of:\\r\\nExampleClass: 12 bytes for metadata + 3x 4 bytes for int + 4 bytes for references = 28 bytes\\r\\n28 bytes + 4 bytes (8 byte alignment) = **32 bytes**\\r\\nInnerClass: 12 bytes for metadata + 2x 4 bytes for inte = 20 bytes - it is not a multiple of 8 bytes (alignment), so: 20 bytes + 4 bytes = 24 bytes.\\r\\n\\r\\n### Compressed vs Uncompressed References\\r\\n\\r\\nDue to the fact that it is aligned to multiples of 8 bytes, we can use an interesting property of writing such numbers in binary form. All multiples of 8 in binary form end with a minimum of three zeros (on the right). Knowing this regularity, JVM programmers took advantage of this property by shifting it 3 bits to the left, which gives us an additional 3 bits to write memory addresses. Which increases the range from 2^32~4GB to 2^(32+3)~32GB.\\r\\n\\r\\n**This allows for more than 4GB of heap space with 32-bit references on 64-bit machines!**\\r\\n\\r\\n![Bit shifting](/blog/bit-shifting.png)\\r\\n\\r\\nBy default, reference compression is enabled. This means that the class word takes 4 entities and each reference takes 4 entities. Such settings have a limit of **32 GB heap.** When we use more than 32 GB heap, compression is automatically turned off. Alternatively, we can manually disable reference compression via *`-XX:-UseCompressedOops`- where this setting disables reference compression and then the reference size is 8 bytes.*\\r\\n\\r\\n### Above 32 GB\\r\\n\\r\\nIf we want to use more than 32 GB of heap and we want to use compressed reference:\\r\\n\\r\\n1. This can be changed with the JVM flag: `-XX:ObjectAlignmentInBytes=16` (Available values 8,16,32,64,128,256, otherwise the JVM will throw an error and will not run the application). A flag that will cause most objects to take up much more unused memory. The advantage of this solution is that we can then use 64 GB Heap with compressed references.*\\r\\n\\r\\nFormula for maximum heap size: 4GB * ObjectAlignmentInBytes. - but remember that allignments increases for each existing object which consequently increases the size of each object. It won\'t always pay off.\\r\\n\\r\\n### What is padding/alligment gap (internal space losses)\\r\\n\\r\\nByte padding to a multiple of 8 bytes can take 2 forms\\r\\n\\r\\n- internal space losses\\r\\n- external space losses\\r\\n\\r\\nThe processor retrieves data 8 bytes at a time. To make it easier to download data, we make shifts. An example of making it easier to retrieve data from internal space losses - the JVM flag *`-XX:ObjectAlignmentInBytes=16`* was used to make the example easier:\\r\\n\\r\\n```\\r\\nSimpleLong object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0    12        (object header)                           N/A\\r\\n     12     4        (alignment/padding gap)                  \\r\\n     16     8   long SimpleLong.state                          N/A\\r\\n     24     8        (loss due to the next object alignment)\\r\\nInstance size: 32 bytes\\r\\nSpace losses: 4 bytes internal + 8 bytes external = 12 bytes total\\r\\n```\\r\\n\\r\\nAfter 12 bytes related to the header, an internal alignment/padding gap = 4 bytes was added. so that extracting the long takes place in one CPU process. (so that the long variable is at offset 16)\\r\\n\\r\\n### Field Packing - Packing of fields\\r\\n\\r\\nThe order in which fields are packed in memory is determined by the JVM, not the declaration of fields in the class implementation. This is to make it easier to condense multiples of 8 bytes so that, for example, an int is not split into 2 data extracts of 8 bytes each.\\r\\n\\r\\n```\\r\\npublic class FieldsArrangement {\\r\\n    private boolean first;\\r\\n    private char second;\\r\\n    private double third;\\r\\n    private int fourth;\\r\\n    private boolean fifth;\\r\\n}\\r\\n...\\r\\nOFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0    12           (object header)                           N/A\\r\\n     12     4       int FieldsArrangement.fourth                  N/A\\r\\n     16     8    double FieldsArrangement.third                   N/A\\r\\n     24     2      char FieldsArrangement.second                  N/A\\r\\n     26     1   boolean FieldsArrangement.first                   N/A\\r\\n     27     1   boolean FieldsArrangement.fifth                   N/A\\r\\n     28     4           (loss due to the next object alignment)\\r\\n```\\r\\n\\r\\n## Other examples - Checking memory size for objects\\r\\n\\r\\n### Array:\\r\\n\\r\\n- Array of booleans\\r\\n\\r\\n    ```java\\r\\n    boolean[] booleans = new boolean[3];\\r\\n    System.out.println(ClassLayout.parseInstance(booleans).toPrintable());\\r\\n    System.out.println(GraphLayout.parseInstance(booleans).toFootprint());\\r\\n    /* Output\\r\\n    [Z object internals:\\r\\n     OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n          0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n          4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n          8     4           (object header)                           00 1b 00 00 (00000000 00011011 00000000 00000000) (6912)\\r\\n         12     4           (object header)                           03 00 00 00 (00000011 00000000 00000000 00000000) (3)\\r\\n         16     3   boolean [Z.<elements>                             N/A\\r\\n         19     5           (loss due to the next object alignment)\\r\\n    Instance size: 24 bytes\\r\\n    Space losses: 0 bytes internal + 5 bytes external = 5 bytes total\\r\\n    \\r\\n    [Z@1068e947d footprint:\\r\\n         COUNT       AVG       SUM   DESCRIPTION\\r\\n             1        24        24   [Z\\r\\n             1                  24   (total)\\r\\n    */\\r\\n    ```\\r\\n\\r\\n- Array of ints\\r\\n\\r\\n    ```java\\r\\n    int[] ints = new int[4];\\r\\n    System.out.println(ClassLayout.parseInstance(ints).toPrintable());\\r\\n    System.out.println(GraphLayout.parseInstance(ints).toFootprint());\\r\\n    /* Output\\r\\n    [I object internals:\\r\\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n          0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n          4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n          8     4        (object header)                           a0 26 00 00 (10100000 00100110 00000000 00000000) (9888)\\r\\n         12     4        (object header)                           04 00 00 00 (00000100 00000000 00000000 00000000) (4)\\r\\n         16    16    int [I.<elements>                             N/A\\r\\n    Instance size: 32 bytes\\r\\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\\r\\n    \\r\\n    [I@5f71c76ad footprint:\\r\\n         COUNT       AVG       SUM   DESCRIPTION\\r\\n             1        32        32   [I\\r\\n             1                  32   (total)\\r\\n    */\\r\\n    ```\\r\\n\\r\\n- ArrayList:\\r\\n\\r\\n```java\\r\\nArrayList<Integer> integers = new ArrayList<>();\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n/*\\r\\njava.util.ArrayList@185a6e9d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        16        16   [Ljava.lang.Object;\\r\\n         1        24        24   java.util.ArrayList\\r\\n         2                  40   (total)\\r\\n*/\\r\\nfor(int i=0; i<100000; i++){\\r\\n            integers.add(i);\\r\\n}\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n\\r\\n//output:\\r\\n/*\\r\\njava.util.ArrayList@185a6e9d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1    426856    426856   [Ljava.lang.Object;\\r\\n    100000        16   1600000   java.lang.Integer\\r\\n         1        24        24   java.util.ArrayList\\r\\n    100002             2026880   (total)\\r\\n*/\\r\\n```\\r\\n\\r\\n2,026,880 bytes = 2mb 27kb for 100,000 ints. (100,000 * 4=400,000 bytes.)\\r\\nWhen we initialize the initial capacity of ArrayList, the memory value is smaller by 26880 bytes (26kb)\\r\\n\\r\\n```java\\r\\nArrayList<Integer> integers = new ArrayList<>(100000);\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n/*\\r\\njava.util.ArrayList@179ece50d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1    400016    400016   [Ljava.lang.Object;\\r\\n         1        24        24   java.util.ArrayList\\r\\n         2              400040   (total)\\r\\n*/\\r\\nfor(int i=0; i<100000; i++){\\r\\n            integers.add(i);\\r\\n}\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n/*\\r\\njava.util.ArrayList@179ece50d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1    400016    400016   [Ljava.lang.Object;\\r\\n    100000        16   1600000   java.lang.Integer\\r\\n         1        24        24   java.util.ArrayList\\r\\n    100002             2000040   (total)\\r\\n*/\\r\\n```\\r\\n\\r\\n- Boolean Wrapper class\\r\\n  - Boolean 16 bytes - details below:\\r\\n\\r\\n  line of code: `System.*out*.println(ClassLayout.*parseClass*(Boolean.class).toPrintable());`\\r\\n\\r\\n  Output:\\r\\n\\r\\n    ```\\r\\n    # WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf\\r\\n    # WARNING: Unable to attach Serviceability Agent. sun.jvm.hotspot.memory.Universe.getNarrowOopBase()\\r\\n    java.lang.Boolean object internals:\\r\\n     OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n          0    12           (object header)                           N/A\\r\\n         12     1   boolean Boolean.value                             N/A\\r\\n         13     3           (loss due to the next object alignment)\\r\\n    Instance size: 16 bytes\\r\\n    Space losses: 0 bytes internal + 3 bytes external = 3 bytes total\\r\\n    ```\\r\\n\\r\\n  The data value takes up 1 byte (8 bits), not 1 bit as it might seem.\\r\\n  12 bytes for metadata + 1 byte for boolean data + 3 bytes of offsets (to be a multiple of 8) = 16 bytes\\r\\n\\r\\n- [String is very interesting so I created another post for this Object type](2024-05-16-String-memory-usage-jvm.md)"},{"id":"regular-expressions","metadata":{"permalink":"/blog/regular-expressions","source":"@site/blog/2024-05-16-regular-expressions.md","title":"Regular expressions","description":"In Short","date":"2024-05-16T00:00:00.000Z","formattedDate":"May 16, 2024","tags":[{"label":"others","permalink":"/blog/tags/others"}],"readingTime":2.88,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"regular-expressions","title":"Regular expressions","authors":"bjab","tags":["others"]},"prevItem":{"title":"Checking memory alocation of Objects - JOL library (Java Object Layout)","permalink":"/blog/jvm-memory-allocation-of-objects"},"nextItem":{"title":"Calculating the memory usage by a String in JVM - JOL Footprint","permalink":"/blog/string-in-jvm-memory"}},"content":"## In Short\\r\\n- Consists of a sequence of atoms (an atom is a literal - letter, digit, special character)\\r\\n- Letters are case sensitive\\r\\n- You can test regexes in online tools like: https://regex101.com/\\r\\n\x3c!-- truncate --\x3e\\r\\n## Quantifiers\\r\\n\\r\\nThe quantifier tells how many occurrences of a given atom there can be. A quantifier refers to the element to the left of the quantifier. If there is no quantifier next to an atom, it means that the atom will have one occurrence (in the examples below, atom `b` always has one occurrence.\\r\\n\\r\\n- `*` - zero or more occurrences\\r\\n\\r\\n  e.g. `a*b` can translate into, among others, the following expressions: `b`, `ab`, `aab`, `aaaaaaab`, \u2026\\r\\n\\r\\n- `+` - one or more occurrences\\r\\n\\r\\n  e.g. `a+b` can translate into, among others, the following expressions: `ab`, `aab`, `aaaaab`, \u2026\\r\\n\\r\\n- `?` - zero or one occurrence\\r\\n\\r\\n  e.g. `a?b` translates to `b`, `ab`\\r\\n\\r\\n- `{min,max}` - At least `min` occurrences and maximum `max` occurrences\\r\\n\\r\\n  e.g. `a{2,4}b` translates into the expressions: `aab`, `aaab`, `aaaab`\\r\\n\\r\\n- `{min,}` - At least `min` occurrences. The maximum can be infinite.\\r\\n- `{,max}` - There is no minimum number of occurrences, and the maximum can be `max` occurrences\\r\\n- `{n}` - the exact number of occurrences equal to `n`\\r\\n\\r\\n  e.g. `a{4}b` - translates into: `aaaab`\\r\\n\\r\\n\\r\\n## Ranges []\\r\\n\\r\\nRange means that the expression can be one letter/number from a range. The dash `-` denotes a range from, to.\\r\\n\\r\\n- `[abc]` - means that the expression will be `a` or `b` or `c` (only one letter)\\r\\n- `[a-bB-Z]` - the expression can be `a`, `b`, `B`, `C`, `D`, \u2026, `Z`\\r\\n- `[a-Z]` - the expression can be any English character (uppercase or lowercase)\\r\\n- `[0-9]` - the expression can be any digit\\r\\n- `[a-Z\u0105\u0107\u0119\u0142\u0144\xf3\u015b\u017a\u017c\u0104\u0118\u0141\u0143\xd3\u015a\u0179\u017b]` - range of all Polish characters.\\r\\n\\r\\n## Groups ()\\r\\n\\r\\n- `(ab){2}` - means the expression `abab`\\r\\n\\r\\n#Flags\\r\\n\\r\\n- `(?i)` - ignore the case of letters to the right of this character\\r\\n\\r\\n## Special signs\\r\\n\\r\\n- `.` - any character\\r\\n- `$` - end of line (if we use this character at the end, it means that there is no character after the searched expression.\\r\\n- `^` - beginning of the line (if we use this character at the beginning, it means that there is no character before the searched expression.\\r\\n- `[^e]` - negation - the expression will not contain the letter `e`.\\r\\n- `|` - the sign means logical or, i.e. the expression will be any expression separated by the `|` sign\\r\\n\\r\\n  e.g. `a|b` - means `a` or `b`\\r\\n\\r\\n- `\\\\s` - Space, tab or newline\\r\\n- `\\\\S` - A character that is the negation of `\\\\s`, i.e. a character that is not a space, tab or newline character\\r\\n- `\\\\w` - letter, digit or character `_` (equivalent to `[a-Z_]`\\r\\n- `\\\\W` - a character that is the negation of `\\\\w`, i.e. a character that is not a letter, digit or `_`\\r\\n- `\\\\d` - digit (equivalent to `[0-9]`)\\r\\n- `\\\\D` - a character that is the negation of `\\\\d`, i.e. a character that is not a digit\\r\\n- `\\\\b` - Any whitespace character, the beginning of a string, the end of a string, and any character that is neither a letter nor a digit.\\r\\n\\r\\n**If we want to use one of the special characters in the regular expression such as `.`, `*`, `/`, `?`, `:`, `.`, `^`, `+`, `\\\\`, `=`, `|`, then we precede it with the `\\\\` character, e.g. `\\\\.`**"},{"id":"string-in-jvm-memory","metadata":{"permalink":"/blog/string-in-jvm-memory","source":"@site/blog/2024-05-16-String-memory-usage-jvm.md","title":"Calculating the memory usage by a String in JVM - JOL Footprint","description":"In short:","date":"2024-05-16T00:00:00.000Z","formattedDate":"May 16, 2024","tags":[{"label":"jvm","permalink":"/blog/tags/jvm"},{"label":"jol","permalink":"/blog/tags/jol"},{"label":"string","permalink":"/blog/tags/string"},{"label":"heap","permalink":"/blog/tags/heap"},{"label":"memory","permalink":"/blog/tags/memory"}],"readingTime":6.615,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"string-in-jvm-memory","title":"Calculating the memory usage by a String in JVM - JOL Footprint","authors":"bjab","tags":["jvm","jol","string","heap","memory"]},"prevItem":{"title":"Regular expressions","permalink":"/blog/regular-expressions"},"nextItem":{"title":"Free YouTube Playlist Downloader to mp3 or mp4 - No Ads, No Hassle","permalink":"/blog/python-youtube-downloader"}},"content":"## In short:\\r\\n\\r\\n- The memory of the String object consists of 24 bytes for metadata + the number of characters times 1 byte or 2 bytes depending on the coder value\\r\\n  - Metadata: mark word x2 (4 bytes x2 = 8 bytes), class word (4 bytes), array reference byte[] or char[] (4 byte), hash (4 byte), hashIsZero (1 byte), coder (1 byte), padding (2 byte)\\r\\n- The String object has 2 additional flags:\\r\\n  - when `coder =1` then UTF-16 encoding (2 bytes per character)\\r\\n  - when `coder = 0` then LATIN-1 encoding (1 byte per character)\\r\\n  - hashIsZero is a flag that tells whether the hash calculation has already been performed\\r\\n\x3c!-- truncate --\x3e\\r\\n\\r\\n## JOL - String\\r\\n\\r\\nSince Java 9 we use Compact String, i.e. if possible, we use LATIN-1 encoding, and if not, coder=1 is set and we use UTF-16.\\r\\n\\r\\n(Before Java 9, everything was char[] and each letter was equal to 2 byte Utf-16.)\\r\\n\\r\\nIf at least one character is other than latin-1 (1 byte), each character in the String is encoded in utf16 (2 byte).\\r\\n\\r\\n```java\\r\\nString utf16String = \\"Bartosz Jab\u0142o\u0144ski\\"; // 17 znak\xf3w x 2 bytes = 34 bytes\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String).toPrintable());\\r\\nSystem.out.println(GraphLayout.parseInstance(utf16String).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String.getBytes()).toPrintable());\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());\\r\\n       \\r\\nString latin1String = \\"Bartosz Jablonski\\"; // 17 znak\xf3w x 1 bytes = 17 bytes\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String).toPrintable());\\r\\nSystem.out.println(GraphLayout.parseInstance(latin1String).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String.toCharArray()).toPrintable());\\r\\n```\\r\\n\\r\\n```\\r\\n#### Bartosz Jab\u0142o\u0144ski - UTF-16 - coder:1\\r\\njava.lang.String object internals:\\r\\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\\r\\n     12     4       int String.hash                               0\\r\\n     16     1      byte String.coder                              1\\r\\n     17     1   boolean String.hashIsZero                         false\\r\\n     18     2           (alignment/padding gap)                  \\r\\n     20     4    byte[] String.value                              [66, 0, 97, 0, 114, 0, 116, 0, 111, 0, 115, 0, 122, 0, 32, 0, 74, 0, 97, 0, 98, 0, 66, 1, 111, 0, 68, 1, 115, 0, 107, 0, 105, 0]\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\\r\\n\\r\\njava.lang.String@7dc222aed footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        56        56   [B\\r\\n         1        24        24   java.lang.String\\r\\n         2                  80   (total)\\r\\n\\r\\n[B object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\\r\\n     12     4        (object header)                           13 00 00 00 (00010011 00000000 00000000 00000000) (19)\\r\\n     16    19   byte [B.<elements>                             N/A\\r\\n     35     5        (loss due to the next object alignment)\\r\\nInstance size: 40 bytes\\r\\nSpace losses: 0 bytes internal + 5 bytes external = 5 bytes total\\r\\n\\r\\n[C object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    34   char [C.<elements>                             N/A\\r\\n     50     6        (loss due to the next object alignment)\\r\\nInstance size: 56 bytes\\r\\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\\r\\n```\\r\\n\\r\\nIn the first case, for `Bartosz Jab\u0142o\u0144ski`, where we included Polish characters not included in LATIN-1, you can see that the String has the `coder` flag set to `1`, i.e. it uses the `UTF-16` encoding type (2 bytes per character).\\r\\n\\r\\nThe footprint shows the deep size of the String object (17 characters) is 80 bytes. It consists of String and its metadata and the String object, i.e. the char[] array in UTF-16 encoding (2 byte per character).\\r\\nTo sum up:\\r\\n\\r\\n- 24 bytes - String with a reference takes 24 bytes (12 bytes for metadata (headers) + 4 bytes for hash(int) + 1 byte for coder, + 1 byte for hashIsZero + 4 bytes of references to the char array + 2 bytes for alligment padding ).\\r\\n  - Where the coder is responsible for: This value is closely related to the JVM implementation (hotspot). This is the encoding identifier used to encode bytes. Supported values are LATIN1 (coder=0) and UTF16(coder=1).\\r\\n         If at least one letter **is not included in LATIN1**, then coder=1 and the entire String will be encoded to UTF-16, i.e. it will take up (n letters * 2 bytes) in memory.\\r\\n        \\r\\n     - Where hashIsZero is responsible for: This field tells the JVM whether it can bypass hash recalculation. (this kind of cache)\\r\\n\\r\\n- 56 bytes - The byte[] array occupies 56 bytes, which consists of: 12 bytes of metadata (headers) + 4 bytes of metadata about the array (length) + data 17 characters * 2 bytes (34 bytes) = 50 bytes + 6 bytes for alignment . This is non-intuitively illustrated by the line of code: `System.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());`\\r\\n```java\\r\\n#### Bartosz Jablonski - LATIN-1 - coder:0\\r\\njava.lang.String object internals:\\r\\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\\r\\n     12     4       int String.hash                               0\\r\\n     16     1      byte String.coder                              0\\r\\n     17     1   boolean String.hashIsZero                         false\\r\\n     18     2           (alignment/padding gap)                  \\r\\n     20     4    byte[] String.value                              [66, 97, 114, 116, 111, 115, 122, 32, 74, 97, 98, 108, 111, 110, 115, 107, 105]\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\\r\\n\\r\\njava.lang.String@48a242ced footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        40        40   [B\\r\\n         1        24        24   java.lang.String\\r\\n         2                  64   (total)\\r\\n\\r\\n[B object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    17   byte [B.<elements>                             N/A\\r\\n     33     7        (loss due to the next object alignment)\\r\\nInstance size: 40 bytes\\r\\nSpace losses: 0 bytes internal + 7 bytes external = 7 bytes total\\r\\n\\r\\n[C object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    34   char [C.<elements>                             N/A\\r\\n     50     6        (loss due to the next object alignment)\\r\\nInstance size: 56 bytes\\r\\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\\r\\n```\\r\\n\\r\\nIn the second case for `Bartosz Jablonski`, where we did not include Polish characters, you can see that String has the coder flag set to 0, i.e. it uses LATIN-1 encoding (1 byte per character).\\r\\n\\r\\nThe footprint shows the deep size of the String object (17 characters) is 64 bytes. It consists of String and its metadata and the String object, i.e. the byte[] array in LATIN-1 encoding (1 byte per character).\\r\\n\\r\\n- String with a reference takes 24 bytes (12 bytes for metadata (headers) + 4 bytes for hash(int) + 1 byte for coder + 1 byte for hashIsZero + 4 bytes for references to the array of entities + 2 bytes for alligment padding).\\r\\n- The byte[] array takes 40 bytes, which consists of: 12 bytes of metadata (headers) + 4 bytes of metadata about the array (length) + 17 character data * 1 byte (17 bytes) = 33 bytes + 7 bytes for alignment.\\r\\n\\r\\nThis is illustrated by the line of code: `System.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());`\\r\\n\\r\\nThanks to the `coder` flag and the lack of special characters, we have a gain of 16 bytes in less memory consumption - which happens without our programming intervention."},{"id":"python-youtube-downloader","metadata":{"permalink":"/blog/python-youtube-downloader","source":"@site/blog/2024-05-16-youtube-downloader.md","title":"Free YouTube Playlist Downloader to mp3 or mp4 - No Ads, No Hassle","description":"I recently stopped using Spotify Premium and it has become more difficult to listen to music and podcasts on the plane. So far, I have downloaded mp3 and mp4 using online tools such as:","date":"2024-05-16T00:00:00.000Z","formattedDate":"May 16, 2024","tags":[{"label":"python","permalink":"/blog/tags/python"},{"label":"scripts","permalink":"/blog/tags/scripts"},{"label":"tools","permalink":"/blog/tags/tools"}],"readingTime":3.435,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"python-youtube-downloader","title":"Free YouTube Playlist Downloader to mp3 or mp4 - No Ads, No Hassle","authors":"bjab","tags":["python","scripts","tools"]},"prevItem":{"title":"Calculating the memory usage by a String in JVM - JOL Footprint","permalink":"/blog/string-in-jvm-memory"}},"content":"I recently stopped using Spotify Premium and it has become more difficult to listen to music and podcasts on the plane. So far, I have downloaded mp3 and mp4 using online tools such as:\\r\\n\\r\\n- https://notube.net/pl/youtube-app-v103\\r\\n- https://y2down.cc/pl/youtube-mp4.html and others\\r\\n\\r\\nUnfortunately, tools of this type allow you to download individual videos and bombard us with a lot of invasive advertisements. To avoid these problems, we will write a script in Python which, after providing a link to a playlist or movie, will download an mp3 or mp4.\\r\\n\\r\\nWe will use the library [pytube](https://pytube.io/en/latest/) to write the script .\\r\\n\\r\\nYou can find the entire script in the repository gitlab: https://gitlab.com/bart_as93/youtube-downloader\\r\\n\x3c!-- truncate --\x3e\\r\\n### 1. Initial setup\\r\\n\\r\\nClone the repository to your local machine:\\r\\n\\r\\n```bash\\r\\ngit clone https://gitlab.com/bart_as93/youtube-downloader.git\\r\\ncd youtube-downloader\\r\\n```\\r\\n\\r\\nCheck python versions\\r\\n\\r\\n```bash\\r\\npython --version\\r\\n```\\r\\n\\r\\nIn my case `Python 3.11.4`\\r\\n\\r\\nThen we install the dependencies\\r\\n\\r\\n```bash\\r\\npip install -r requirements.txt\\r\\n```\\r\\n\\r\\nThen we run the script, e.g.:\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -u https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d music -f mp4\\r\\n```\\r\\n\\r\\nThe script takes 4 arguments:\\r\\n\\r\\n- `-f` - format one of: mp3 or mp4\\r\\n- `-d` - directory where to download files\\r\\n- and one of below:\\r\\n    - `-u` - Url to youtube video\\r\\n    - `-pu` - Url to playlist\\r\\n\\r\\n### YouTube to mp4\\r\\n\\r\\nTo download a YouTube video you need to use the `-u <link_to_video>` flag and `f mp4` flag\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -u https://www.youtube.com/watch?v=a59gmGkq_pw -d movies -f mp4\\r\\n```\\r\\n\\r\\n### YouTube to mp3\\r\\n\\r\\nTo download audio from YouTube video you need to use the `-u <link_to_video>` flag and `-f mp3` flag.\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -u https://www.youtube.com/watch?v=a59gmGkq_pw -d music -f mp3\\r\\n```\\r\\n\\r\\n### YouTube Playlist to mp4\\r\\n\\r\\nTo download videos from YouTube playlist you need to use `-pu <link_to_playlist>` flag and `-f mp4` flag.\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -pu https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d music-f mp4\\r\\n```\\r\\n\\r\\n### YouTube Playlist to mp3\\r\\n\\r\\nTo download audio from YouTube playlist you need to use `-pu <link_to_playlist>` flag and `-f mp3` flag.\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -pu https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d movies -f mp3\\r\\n```\\r\\n\\r\\n## Code overview (comments in code):\\r\\n\\r\\n```python\\r\\nimport argparse\\r\\nimport os\\r\\nfrom pytube import Playlist\\r\\nfrom pytube import YouTube\\r\\n\\r\\n# The program supports two formats: mp3 and mp4. In the else section, if the format is different, the program is disabled\\r\\ndef downloadByVideo(vid):\\r\\n    print(\'downloading : {} - {} with url : {}\'.format(video.author, video.title, video.watch_url))\\r\\n    global type\\r\\n    vidFileName = vid.author + \\" - \\" + vid.title + \\".\\" + format\\r\\n    if format == \'mp3\':\\r\\n        type = \'audio\'\\r\\n# On the video object, we refer to streams, filter only audio and call the download method with options describing the target directory in which the file will be saved and the file name\\r\\n        vid.streams. \\\\\\r\\n            filter(only_audio=True).desc().first(). \\\\\\r\\n            download(output_path=DOWNLOAD_DIR, filename=vidFileName)\\r\\n    elif format == \'mp4\':\\r\\n        type = \'video\'\\r\\n# On the video object, we refer to streams, filter only the video, sort from the highest resolution and call the download method with options describing the target directory in which the file will be saved and the file name\\r\\n        vid.streams. \\\\\\r\\n            filter(type=type, progressive=True, file_extension=format). \\\\\\r\\n            order_by(\'resolution\'). \\\\\\r\\n            desc(). \\\\\\r\\n            first(). \\\\\\r\\n            download(output_path=DOWNLOAD_DIR, filename=vidFileName)\\r\\n    else:\\r\\n        print(f\\"Not supported format type: {format}\\")\\r\\n        exit()\\r\\n\\r\\n# Handling command line parameters and checking required fields\\r\\nparser = argparse.ArgumentParser()\\r\\n\\r\\nparser.add_argument(\\"-u\\", \\"--Url\\", help=\\"Youtube video url\\")\\r\\nparser.add_argument(\\"-pu\\", \\"--PlayListUrl\\", help=\\"Playlist url\\")\\r\\nparser.add_argument(\\"-f\\", \\"--Format\\", help=\\"Format of downloaded files - mp3 or mp4\\")\\r\\nparser.add_argument(\\"-d\\", \\"--Destination\\", help=\\"Destination folder of downloaded files\\")\\r\\n\\r\\nformat=\\"mp3\\"\\r\\n\\r\\nargs = parser.parse_args()\\r\\n\\r\\nif not args.Url and not args.PlayListUrl:\\r\\n    print(\\"Please provide youtube playlist url via -pu or --PlayListUrl argument param or Youtube video url via -u or --Url\\")\\r\\n    exit()\\r\\nif not args.Destination:\\r\\n    print(\\"Please provide destination folder name via -d or --Destination argument param\\")\\r\\n    exit()\\r\\nif not args.Format:\\r\\n    print(\\"Format (-f or --Format not provided - default set to mp3\\")\\r\\nelse:\\r\\n    format=args.Format\\r\\n\\r\\nDOWNLOAD_DIR = os.getcwd() + \\"\\\\\\\\out\\\\\\\\\\" + args.Destination\\r\\n\\r\\n# We check whether the URL to the Playlist (-pu) or the URL to the movie (-u) has been entered and the movie or playlist is downloaded based on the URL\\r\\nif(args.PlayListUrl):\\r\\n    playlist = Playlist(args.PlayListUrl)\\r\\n    print (f\\"Downloading {len(playlist.videos)} files from playlist with url: {args.Url}, with format: {args.Format}, to dir: {DOWNLOAD_DIR}\\")\\r\\n\\r\\n    for video in playlist.videos:\\r\\n        downloadByVideo(video)\\r\\n\\r\\nif (args.Url):\\r\\n    video = YouTube(args.Url)\\r\\n    downloadByVideo(video)\\r\\n```"}]}')}}]);