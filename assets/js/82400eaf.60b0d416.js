(self.webpackChunklearning_notes=self.webpackChunklearning_notes||[]).push([[8021],{31662:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>E,contentTitle:()=>D,default:()=>_,frontMatter:()=>O,metadata:()=>Z,toc:()=>R});var r=t(85893),s=t(11151),i=t(61830),o=t(72796);const l="// Input: nums = [1,2,3,4]\n// Output: [1,3,6,10]\n// Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar runningSum = function (nums) {\n    const sum = Array(nums.length).fill(0);\n\n    sum[0] = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        sum[i] = sum[i - 1] + nums[i];\n    }\n    return sum;\n};\n\nconsole.log(runningSum([1, 2, 3, 4])); // [1,3,6,10]\n\n\nconsole.log(runningSum([1, 7, 3, 6, 5, 6]));\nconsole.log(runningSum([1, 7, 3, 6, 5, 6].reverse()));",a="// e.g 1\n// Input: nums = [1,7,3,6,5,6]\n// Output: 3\n// Explanation:\n// The pivot index is 3.\n// Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\n// Right sum = nums[4] + nums[5] = 5 + 6 = 11\n\n// e.g. 2\n// Input: nums = [1,2,3]\n// Output: -1\n// Explanation:\n// There is no index that satisfies the conditions in the problem statement.\n\n// e.g. 3\n// Input: nums = [2,1,-1]\n// Output: 0\n// Explanation:\n// The pivot index is 0.\n// Left sum = 0 (no elements to the left of index 0)\n// Right sum = nums[1] + nums[2] = 1 + -1 = 0\n\nvar pivotIndex = function (nums) {\n    let leftSum = 0;\n    let rightSum = sum(nums);\n    for (let i = 0; i < nums.length; i++) {\n        rightSum = rightSum - nums[i];\n        if (leftSum === rightSum) return i;\n        leftSum += nums[i];\n    }\n\n    return -1;\n};\n\n\nvar runningSum = function (nums) {\n    const sum = Array(nums.length).fill(0);\n\n    sum[0] = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        sum[i] = sum[i - 1] + nums[i];\n    }\n    return sum;\n};\n\n\n//  0   1   2   3    4  5\n// [1,  7,  3,  6,   5, 6]\n// [1,  8,  11, 17, 22, 28] look at the element on the left of the i-th element\n// [28, 27, 20, 17, 11, 6]  look at the element on the right of the i-th element\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar pivotIndex1 = function (nums) {\n    let leftRunningSum = runningSum(nums);\n    let rightRunningSum = runningSum([...nums].reverse()).reverse();\n\n    let leftSum = 0;\n    let rightSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        leftSum = leftRunningSum[i - 1]\n        rightSum = rightRunningSum[i + 1]\n        if (leftSum === undefined) leftSum = 0;\n        if (rightSum === undefined) rightSum = 0;\n\n\n        if (leftSum === rightSum) return i;\n    }\n\n    return -1;\n};\n\nvar sum = nums => nums.reduce((accumulator, currentValue) => accumulator + currentValue, 0)\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\n\nconsole.log(pivotIndex([1, 7, 3, 6, 5, 6])); // 3\nconsole.log(pivotIndex([1, 2, 3])); // -1\nconsole.log(pivotIndex([2, 1, -1])); // 0",c='/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isIsomorphic = function (s, t) {\n    if (s.length !== t.length) return false;\n    const map = {};\n    const values = new Set();\n\n    for (let i = 0; i < s.length; i++) {\n        const leftChar = s[i];\n        const rightChar = t[i];\n\n        if (map[leftChar] === undefined) {\n            if (values.has(rightChar)) return false\n            map[leftChar] = rightChar;\n            values.add(rightChar)\n\n            continue;\n        }\n\n        const mappedChar = map[leftChar];\n        if (mappedChar !== rightChar) {\n            return false\n        }\n    }\n    return true\n};\n\nconsole.log(isIsomorphic("egg", "add")); // true\nconsole.log(isIsomorphic("foo", "bar")); // false\nconsole.log(isIsomorphic("paper", "title")); // true\nconsole.log(isIsomorphic("badc", "baba")); // false  b->b   a->a   d->b  c->a\n\n// No two characters may map to the same character, but a character may map to itself.',d='/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function (s, t) {\n    let startIdx = 0;\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        for (let j = startIdx; j < t.length; j++) {\n            if (char === t[j]) {\n                count++;\n                startIdx = j + 1;\n                break;\n            }\n        }\n    }\n\n    return s.length === count;\n};\n\n\nconsole.log(isSubsequence("abc", "ahbgdc")); // true\nconsole.log(isSubsequence("axc", "ahbgdc")); // false\n\nconsole.log(isSubsequence("bc", "abagdc")); // true\nconsole.log(isSubsequence("aa", "abagdc")); // true',h="function ListNode(val, next) {\n    this.val = (val === undefined ? 0 : val)\n    this.next = (next === undefined ? null : next)\n}\n\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n    const dummy = new ListNode();\n\n    let current = dummy;\n    let left = list1;\n    let right = list2;\n    while (left && right) {\n        if (left.val <= right.val) {\n            current.next = new ListNode(left.val)\n            left = left.next\n        } else {\n            current.next = new ListNode(right.val);\n            right = right.next\n        }\n\n        current = current.next;\n    }\n\n    // deal with the remaining numbers\n    if (left || right) {\n        current.next = left ? left : right\n    }\n\n    return dummy.next;\n};\n\n/**\n * \n * @param {ListNode} root \n */\nfunction print(root) {\n    let current = root;\n    while (current) {\n        console.log(current.val);\n        current = current.next;\n    }\n}\n/**\n * \n * @param {number[]} nums \n */\nfunction toListNode(nums) {\n    const dummy = new ListNode();\n    let current = dummy;\n    nums.forEach(num => {\n        current.next = new ListNode(num);\n        current = current.next\n    })\n    return dummy.next\n}\n\nprint(mergeTwoLists(toListNode([1, 2, 4]), toListNode([1, 3, 4])))",u="function ListNode(val, next) {\n    this.val = (val === undefined ? 0 : val)\n    this.next = (next === undefined ? null : next)\n}\n\nvar reverseList = function (head) {\n    let prevHead = null;\n    let nextHead = null;\n    while (head) {\n        nextHead = head.next;\n        head.next = prevHead;\n\n        prevHead = head;\n        head = nextHead;\n    }\n    return prevHead;\n};\n\n/**\n * @param {ListNode} head\n * @return {ListNode} the reversed list\n */\nvar reverseList1 = function (head) {\n    // no element []\n    if (!head) return head;\n\n    // only one element [1]\n    if (!head.next) return head;\n\n    // the first node's prev node is null\n    let prevNode = null;\n    let movingNode = head.next;\n    // connect the first node's next to null\n    head.next = prevNode;\n    prevNode = head;\n\n    while (movingNode) {\n        let temp = movingNode.next;\n        // connect to the moving node to the left node\n        movingNode.next = prevNode;\n        prevNode = movingNode;\n        movingNode = temp;\n    }\n\n    return prevNode\n};\n\n/**\n * @param {ListNode} root \n */\nfunction print(root) {\n    let current = root;\n    const nums = [];\n    while (current) {\n        nums.push(current.val);\n        current = current.next;\n    }\n    console.log(nums);\n}\n/**\n * @param {number[]} nums \n */\nfunction toListNode(nums) {\n    const dummy = new ListNode();\n    let current = dummy;\n    nums.forEach(num => {\n        current.next = new ListNode(num);\n        current = current.next\n    })\n    return dummy.next\n}\n\nprint(reverseList(toListNode([1, 2]))); // [2,1]\nprint(reverseList(toListNode([1, 2, 3, 4, 5]))); // [5,4,3,2,1]\n",m="function ListNode(val, next) {\n    this.val = (val === undefined ? 0 : val)\n    this.next = (next === undefined ? null : next)\n}\n\nvar middleNode1 = function (head) {\n    let length = 0;\n    const dummy = new ListNode();\n    dummy.next = head;\n\n    while (head) {\n        length++;\n        head = head.next;\n    }\n\n    let middle = dummy.next;\n    for (let i = 0; i < Math.floor(length / 2); i++) {\n        middle = middle.next;\n    }\n\n    return middle;\n};\n\n\n/**\n * Fast and Slow Pointer\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    return slow;\n};\n\nfunction print(root) {\n    let current = root;\n    const nums = [];\n    while (current) {\n        nums.push(current.val);\n        current = current.next;\n    }\n    console.log(nums);\n}\n\nfunction toListNode(nums) {\n    const dummy = new ListNode();\n    let current = dummy;\n    nums.forEach(num => {\n        current.next = new ListNode(num);\n        current = current.next\n    })\n    return dummy.next\n}\n\nprint(middleNode(toListNode([1, 2, 3, 4, 5]))); // [3,4,5]\nprint(middleNode(toListNode([1, 2, 3, 4, 5, 6]))); // [4,5,6]\n",p="function ListNode(val, next) {\n    this.val = (val === undefined ? 0 : val)\n    this.next = (next === undefined ? null : next)\n}\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function (head) {\n    // There is a cycle in a linked list if there is some node in the list that can be reached again\n    const s = new Set();\n    while (head) {\n        if (s.has(head)) return head;\n        s.add(head);\n        head = head.next;\n    }\n\n    return null;\n};",g="/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit1 = function (prices) {\n    if (prices.length === 1) return 0;\n\n    let max = 0;\n    let maxSellPrice = 0;\n    let maxSellPriceIdx = -1;\n    for (let i = 0; i < prices.length; i++) {\n        const buyPrice = prices[i];\n        // find max sell price after current day\n        if (i >= maxSellPriceIdx) {\n            const remainingPrices = prices.slice(i);\n            maxSellPrice = Math.max(...remainingPrices);\n            maxSellPriceIdx = remainingPrices.lastIndexOf(maxSellPrice);\n        }\n        max = Math.max(maxSellPrice - buyPrice, max);\n\n    }\n    return max;\n};\n\n/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n    let maxProfit = 0;\n    let minPrice = Number.MAX_VALUE;\n\n    prices.forEach(price => {\n        minPrice = Math.min(minPrice, price);\n        let profit = price - minPrice;\n        maxProfit = Math.max(maxProfit, profit)\n    })\n\n    return maxProfit\n}\n\nconsole.log(maxProfit([7, 1, 5, 3, 6, 4])); // 5\nconsole.log(maxProfit([7, 6, 4, 3, 1])); // 0\nconsole.log(maxProfit([1])); // 0\nconsole.log(maxProfit([1, 2])); // 1",x='/**\n * @param {string} s\n * @return {number}\n */\nvar longestPalindrome = function (s) {\n    if (s.length === 1) return 1;\n\n    const termFreq = tf(s);\n    console.log(termFreq);\n    let length = 0;\n\n    for (const count of Object.values(termFreq)) {\n        if (count % 2 === 0) {\n            length += count;\n        } else {\n            length += count - 1;\n        }\n\n        // we can only add 1 unique char to the center\n        // length % 2 === 0 means we haven\'t added a unique center char\n        if (length % 2 === 0 && count % 2 === 1) {\n            length++;\n        }\n    }\n\n    return length\n};\n/**\n * Get the term frequency of a string\n * @param {string} s \n */\nfunction tf(s) {\n    const termFreq = {};\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        if (termFreq[char]) {\n            termFreq[char] += 1\n        } else {\n            termFreq[char] = 1;\n        }\n    }\n    const sortable = Object.fromEntries(\n        Object.entries(termFreq).sort(([, a], [, b]) => b - a)\n    );\n\n    return sortable;\n}\n\nconsole.log(longestPalindrome("abccccdde") === 7); // 7, e.g., dccaccd | ccdcc\nconsole.log(longestPalindrome("a") === 1); // 1\nconsole.log(longestPalindrome("bb") === 2); // 2\n\nconsole.log(longestPalindrome("bananas") === 5); // 5 e.g. naban | odd even\nconsole.log(longestPalindrome("ccccdd") === 6); // 6 e.g. ccddcc\n\nconsole.log(longestPalindrome("aaaa") === 4);\nconsole.log(longestPalindrome("tattarrattat") === 12);\nconsole.log(longestPalindrome("tattarrattatxx") === 14); // tatta  rxxr attat',f="/**\n * Definition for a Node.\n * @param {number} val \n * @param {Node[]} children \n */\nfunction TreeNode(val, children) {\n    this.val = val;\n    this.children = children;\n};\n\n/**\n * @param {Node|null} root\n * @return {number[]}\n */\nvar preorderRecursive = function (root) {\n    // root left right\n    const result = [];\n    _preorder(root, result);\n    return result\n};\n\nvar _preorder = function (root, array) {\n    if (!root) return\n    array.push(root.val)\n    root.children?.forEach(node => {\n        _preorder(node, array)\n    })\n}\n\n// preorderIterative\nconst preorder = (root) => {\n    if (!root) return [];\n\n    const result = [];\n    const stack = [root];\n\n    while (stack.length) {\n        const node = stack.pop()\n        if (node.children) {\n            stack.push(...node.children.reverse())\n        }\n        result.push(node.val)\n    }\n\n    return result;\n}\n\nconst root = new TreeNode(1);\nconst three = new TreeNode(3);\nconst two = new TreeNode(2);\nconst four = new TreeNode(4);\nconst five = new TreeNode(5);\nconst six = new TreeNode(6);\n\nroot.children = [three, two, four]\nthree.children = [five, six];\n\nconsole.log(preorder(root))",j="// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val)\n    this.left = (left === undefined ? null : left)\n    this.right = (right === undefined ? null : right)\n}\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n    if (!root) return [];\n    const result = []\n    const queue = [root];\n\n    while (queue.length) {\n        const numNodes = queue.length;\n\n        const level = [];\n        // enqueue all the children of each node in the current level\n        for (let i = 0; i < numNodes; i++) {\n            const node = queue.shift();\n            level.push(node.val);\n            node.left && queue.push(node.left);\n            node.right && queue.push(node.right);\n        }\n        // finish current level\n        result.push(level);\n    }\n\n    return result\n};\n\nconst three = new TreeNode(3);\nconst nine = new TreeNode(9);\nconst twenty = new TreeNode(20);\nconst fifteen = new TreeNode(15);\nconst seven = new TreeNode(7);\nconst one = new TreeNode(1);\n\nthree.left = nine;\nthree.right = twenty;\n\ntwenty.left = fifteen;\ntwenty.right = seven\n\nnine.left = one\n\n// Output: [[3],[9,20],[15,7]]\nconsole.log(levelOrder(three));",v="/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let middle = Math.floor((right + left) / 2);\n        const middleNum = nums[middle];\n        if (middleNum < target) {\n            left = middle + 1;\n        } else if (middleNum > target) {\n            right = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    return -1;\n};\n\nconsole.log(search([-1, 0, 3, 5, 9, 12], 9)); // 4\nconsole.log(search([-1, 0, 3, 5, 9, 12, 88], 2)); // -1\nconsole.log(search([5], 5)); // 0\nconsole.log(search([-1, 0, 3, 5, 9, 12], 9)); // 4",b="// give up",y="var isValidBST = function (root) {\n    const nums = [];\n    in_order_traversal(root, (val) => nums.push(val));\n\n    // check if the values are in the correct order\n    for (let i = 0; i < nums.length - 1; i++) {\n        if (!(nums[i] < nums[i + 1])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction in_order_traversal(root, cb) {\n    if (!root) return\n    in_order_traversal(root.left, cb);\n    root && cb(root.val);\n    in_order_traversal(root.right, cb);\n}\n\n// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val)\n    this.left = (left === undefined ? null : left)\n    this.right = (right === undefined ? null : right)\n}\n\n/**\n * Create a binary tree from array and return the root\n * @param {number[]} nums \n * @return {TreeNode} The root of the binary tree\n */\nfunction createTree(nums) {\n    const nodes = nums.map((num => num !== null ? new TreeNode(num) : null));\n    let current = null;\n\n    for (let idx = 0; idx < nums.length; idx++) {\n        // left child: idx * 2 + 1\n        // right child: idx * 2 + 2\n        current = nodes[idx];\n        if (!current) continue\n        current.left = nodes[idx * 2 + 1]\n        current.right = nodes[idx * 2 + 2]\n    }\n    return nodes[0];\n}\n\n// in_order_traversal(createTree([3, 1, 5, 0, 2, 4, 6]), console.log)\nconsole.log(isValidBST(createTree([2, 1, 3])) === true); // true\nconsole.log(isValidBST(createTree([5, 4, 6, null, null, 3, 7])) === false); // false\nconsole.log(isValidBST(createTree([32, 26, 47, 19, null, null, 56, null, 27])) === false); // false\nconsole.log(isValidBST(createTree([3, 1, 5, 0, 2, 4, 6])) === true); // true\nconsole.log(isValidBST(createTree([120, 70, 140, 50, 100, 130, 160, 20, 55, 75, 110, 119, 135, 150, 200])) === false); // false",w="// Definition for a binary tree node.\nfunction TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val)\n    this.left = (left === undefined ? null : left)\n    this.right = (right === undefined ? null : right)\n}\n\n/**\n * Create a binary tree from array and return the root\n * @param {number[]} nums \n * @return {TreeNode} The root of the binary tree\n */\nfunction createTree(nums) {\n    const nodes = nums.map((num => num !== null ? new TreeNode(num) : null));\n    let current = null;\n\n    for (let idx = 0; idx < nums.length; idx++) {\n        // left child: idx * 2 + 1\n        // right child: idx * 2 + 2\n        current = nodes[idx];\n        if (!current) continue\n        current.left = nodes[idx * 2 + 1]\n        current.right = nodes[idx * 2 + 2]\n    }\n    return nodes[0];\n}\n\nfunction levelOrderTraversal(root, cb) {\n    const queue = [root];\n    let levelNum = 0;\n    while (queue.length !== 0) {\n        // num nodes at the current level\n        const numNodes = queue.length;\n        for (let i = 0; i < numNodes; i++) {\n            let currentNode = queue.shift();\n            currentNode.left && queue.push(currentNode.left);\n            currentNode.right && queue.push(currentNode.right);\n            if (cb(currentNode, levelNum)) return\n        }\n        levelNum++;\n    }\n}\n\n/**\n * Search a node in a binary search tree. Use the `.val` to make comparison\n * @param {TreeNode} root root of a binary search tree\n * @param {TreeNode} target the target node to search\n * @return {TreeNode} If the node is found, return the node otherwise null.\n */\nfunction search(root, target) {\n    if (!root) return null;\n    if (root.val === target.val) return root;\n    if (target.val < root.val) return search(root.left, target);\n    if (target.val > root.val) return search(root.right, target);\n    return null;\n}\n\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n    let maxLevel = -Infinity\n    let commonAncestor = null;\n    // level order traversal\n    levelOrderTraversal(root, (node, levelNum) => {\n        // search for p, q\n        if (search(node, p) && search(node, q)) {\n            if (levelNum > maxLevel) {\n                maxLevel = levelNum;\n                commonAncestor = node;\n            }\n        } else {\n            return false\n        }\n    })\n\n    return commonAncestor;\n\n};\n\nfunction eg1() {\n    const root = createTree([6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]);\n    const p = root.left;\n    const q = root.right;\n    console.log(lowestCommonAncestor(root, p, q).val);\n}\n\nfunction eg2() {\n    const root = createTree([6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]);\n    const p = root.left;\n    const q = p.right;\n    console.log(lowestCommonAncestor(root, p, q).val);\n}\n\neg1();\neg2();",S="/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} color\n * @return {number[][]}\n */\nvar floodFill = function (image, sr, sc, color, visited = new Set()) {\n    const startingPixel = image[sr][sc];\n    // any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel\n    // top, bottom, left, right\n    const START = { row: sr, col: sc }\n    const TOP = { row: sr - 1, col: sc }\n    const BOTTOM = { row: sr + 1, col: sc };\n    const LEFT = { row: sr, col: sc - 1 };\n    const RIGHT = { row: sr, col: sc + 1 };\n    const PIXELS = [START, TOP, BOTTOM, LEFT, RIGHT];\n    // Replace the color of all of the aforementioned pixels with color.\n    PIXELS.forEach(neighbor => {\n        const position = `${neighbor.row}-${neighbor.col}`\n        if (visited.has(position)) return;\n        // should have the same color as the starting pixel\n        if (image[neighbor.row] !== undefined && image[neighbor.row][neighbor.col] === startingPixel) {\n            visited.add(position)\n            floodFill(image, neighbor.row, neighbor.col, color, visited);\n            image[neighbor.row][neighbor.col] = color;\n        }\n    })\n    return image\n};\n\nfunction eg1() {\n    const image = [[1, 1, 1], [1, 1, 0], [1, 0, 1]], sr = 1, sc = 1, color = 2\n    console.log(floodFill(image, sr, sc, color))\n}\n\nfunction eg2() {\n    const image = [[0, 0, 0], [0, 1, 0]], sr = 1, sc = 1, color = 2;\n    console.log(floodFill(image, sr, sc, color))\n}\n\neg1()\neg2()",N='\n\n/**\n * @param {character[][]} grid\n * @return {number} The number of islands in the grid.\n */\nvar numIslands = function (grid) {\n\n    function dfs(grid, sr, sc, visited) {\n        const START = { row: sr, col: sc }\n        const TOP = { row: sr - 1, col: sc }\n        const BOTTOM = { row: sr + 1, col: sc };\n        const LEFT = { row: sr, col: sc - 1 };\n        const RIGHT = { row: sr, col: sc + 1 };\n        const POSITIONS = [START, TOP, BOTTOM, LEFT, RIGHT];\n        for (let i = 0; i < POSITIONS.length; i++) {\n            const position = POSITIONS[i];\n            const coordinate = `${position.row}-${position.col}`\n            if (visited.has(coordinate)) continue\n            if (grid[position.row] !== undefined && grid[position.row][position.col] === "1") {\n                visited.add(coordinate);\n                dfs(grid, position.row, position.col, visited);\n            }\n        }\n\n    }\n    const visited = new Set();\n    let numVisited = -1;\n    let count = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[0].length; col++) {\n            if (grid[row][col] === "0") continue\n            const coordinate = `${row}-${col}`;\n            if (visited.has(coordinate)) continue;\n            dfs(grid, row, col, visited)\n            if (visited.size > 0 && visited.size !== numVisited) {\n                numVisited = visited.size;\n                count++;\n            }\n        }\n    }\n\n    return count\n};\n\n// explore all 1s at the current region, when the stack is empty, increment numIslands by 1\n// start from the water, find the land which has not visited\n// if a land is found, exploring all 1s started from the land\n\nfunction eg1() {\n    const grid = [\n        ["1", "1", "1", "1", "0"],\n        ["1", "1", "0", "1", "0"],\n        ["1", "1", "0", "0", "0"],\n        ["0", "0", "0", "0", "0"]\n    ]\n\n    console.log(numIslands(grid)); // 1\n}\n\nfunction eg2() {\n    const grid = [\n        ["1", "1", "0", "0", "0"],\n        ["1", "1", "0", "0", "0"],\n        ["0", "0", "1", "0", "0"],\n        ["0", "0", "0", "1", "1"]\n    ]\n\n    console.log(numIslands(grid)); // 3\n}\n\nfunction eg3() {\n    const grid = [["0"]]\n    console.log(numIslands(grid)); // 0\n}\n\nfunction eg4() {\n    const grid = [\n        ["0", "1", "0"],\n        ["1", "0", "1"],\n        ["0", "1", "0"]]\n\n    console.log(numIslands(grid)); // 4\n}\n\n\neg1();\neg2();\neg3();\neg4();',k="/**\n * @param {number} n\n * @return {number}\n */\nvar fib = function (n, memo = {}) {\n    if (n in memo) {\n        return memo[n];\n    }\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    const value = fib(n - 1, memo) + fib(n - 2, memo);\n    memo[n] = value;\n    return value;\n};\n\nfunction eg() {\n    console.log(fib(2)); // 1\n    console.log(fib(3)); // 2\n    console.log(fib(4)); // 3\n    console.log(fib(5)); // 5\n\n}\n\neg()",q="/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n, memo = {}) {\n    if (n in memo) return memo[n];\n\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    if (n === 2) return 2;\n    const value = climbStairs(n - 1, memo) + climbStairs(n - 2, memo)\n    memo[n] = value\n    return value;\n};\n\nconsole.log(climbStairs(4)); // 5",T="/**\n * @param {number[]} cost\n * @return {number}\n */\nvar minCostClimbingStairs = function (cost) {\n    for (let i = 0; i < cost.length; i++) {\n        cost[i] += Math.min(cost[i - 1] ?? 0, cost[i - 2] ?? 0)\n    }\n    const n = cost.length;\n    return Math.min(cost[n - 1], cost[n - 2]);\n};\n\nconsole.log(minCostClimbingStairs([10, 15, 20])); // 15\nconsole.log(minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])); // 6\n",I="/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function (m, n) {\n    const dp = Array(m).fill(null).map(() => [...Array(n)].fill(0));\n\n    // initialize the table by filling ones to the bottom and right\n    // fill the bottom line\n    for (let col = 0; col < n; col++) {\n        dp[m - 1][col] = 1;\n    }\n    // fill the right line\n    for (let row = 0; row < m; row++) {\n        dp[row][n - 1] = 1;\n    }\n\n    for (let row = m - 2; row >= 0; row--) {\n        for (let col = n - 2; col >= 0; col--) {\n            dp[row][col] = dp[row + 1][col] + dp[row][col + 1]\n        }\n    }\n\n    return dp[0][0]\n};\n\nconsole.log(uniquePaths(3, 2)); // 3\nconsole.log(uniquePaths(3, 7)); // 28\n",L='function getWordFreq(str) {\n    const freq = {}\n    for (const char of "abcdefghijklmnopqrstuvwxyz") {\n        freq[char] = 0;\n    }\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i]\n        freq[char] += 1;\n    }\n\n    return freq;\n}\n\nfunction isSameFreq(freq1, freq2) {\n    for (const char of "abcdefghijklmnopqrstuvwxyz") {\n        if (freq1[char] !== freq2[char]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nvar findAnagrams = function (s, p) {\n    if (p.length > s.length) return []\n    const wordFreq = getWordFreq(p);\n    const indices = [];\n\n\n    const sliceWordFreq = getWordFreq(s.slice(0, p.length));\n    for (let i = 0; i < s.length; i++) {\n\n        if (isSameFreq(wordFreq, sliceWordFreq)) indices.push(i);\n\n        // remove the current char\n        sliceWordFreq[s[i]] -= 1;\n        // add the next char\n        sliceWordFreq[s[i + p.length]] += 1;\n\n    }\n    return indices\n};\n\nconsole.log(findAnagrams("cbaebabacd", "abc")); // [0, 6]\nconsole.log(findAnagrams("abab", "ab")); // [0, 1, 2]\nconsole.log(findAnagrams("aaaaaaaaaa", "aaaaaaaaaaaaa"));',A='function createFreq() {\n    const freq = {}\n    for (const char of "abcdefghijklmnopqrstuvwxyz".toUpperCase()) {\n        freq[char] = 0;\n    }\n    return freq;\n}\n\nfunction findMaxFreq(freq) {\n    return Math.max(...Object.values(freq));\n}\n\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar characterReplacement = function (s, k) {\n    let left = 0;\n    let right = 0;\n    const freq = createFreq()\n\n    let maxLength = 0;\n\n    while (right < s.length) {\n        freq[s.charAt(right)]++;\n\n        const size = (right - left + 1);\n        const isWindowValid = size - findMaxFreq(freq) <= k\n        if (!isWindowValid) {\n            freq[s.charAt(left)]--;\n            left++;\n        } else {\n            maxLength = Math.max(size, maxLength)\n        }\n        right++;\n    }\n\n    return maxLength;\n};\n\nconsole.log(characterReplacement("AABABBA", 1)); // 4\n\nconsole.log(characterReplacement("ABAB", 2)); // 4\nconsole.log(characterReplacement("ABBB", 2)); // 4\nconsole.log(characterReplacement("ABAA", 0)); // 2\nconsole.log(characterReplacement("AAAB", 0)); // 3\nconsole.log(characterReplacement("AABABBAAAABAAAA", 1)); // 9',P='function getNumFreq(num) {\n  const freq = {};\n  for (const char of "1234567890") {\n    freq[char] = 0;\n  }\n\n  for (let i = 0; i < num.length; i++) {\n    const char = num[i];\n    freq[char] += 1;\n  }\n\n  return freq;\n}\n\n/**\n * @param {string} secret\n * @param {string} guess\n * @return {string}\n */\nvar getHint = function (secret, guess) {\n  let bulls = 0;\n  let cows = 0;\n\n  const secretFreq = getNumFreq(secret);\n  const guessFreq = getNumFreq(guess);\n  for (let i = 0; i < secret.length; i++) {\n    // find bulls - accurate match (same digit with same position)\n    if (secret.charAt(i) === guess.charAt(i)) {\n      bulls++;\n      secretFreq[secret.charAt(i)]--;\n      guessFreq[secret.charAt(i)]--;\n    }\n  }\n\n  for (const digit of Object.keys(secretFreq)) {\n    if (secretFreq[digit] !== 0) {\n      if (guessFreq[digit] >= secretFreq[digit]) {\n        cows += secretFreq[digit];\n      } else {\n        cows += guessFreq[digit];\n      }\n    }\n  }\n\n  return `${bulls}A${cows}B`;\n};\n\nconsole.log(getHint("1807", "7810")); // 1A3B\nconsole.log(getHint("1123", "0111")); // 1A1B\nconsole.log(getHint("1234", "0111")); // "0A1B"\nconsole.log(getHint("1122", "0001")); // 0A1B\n',F='/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  const stack = [];\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (char === "]") {\n      let temp = "";\n      let popped = stack.pop();\n      while (popped !== "[") {\n        temp = popped + temp;\n        popped = stack.pop();\n      }\n\n      // repeat the content\n      let k = "";\n      while (/\\d/.test(stack.at(-1))) {\n        k = stack.pop() + k;\n      }\n      k = Number(k);\n\n      let repeated = "";\n      for (let j = 0; j < k; j++) {\n        repeated += temp;\n      }\n\n      stack.push(repeated);\n    } else {\n      stack.push(char);\n    }\n  }\n\n  return stack.join("");\n};\n\nconsole.log(decodeString("3[a]2[bc]")); // "aaabcbc"\nconsole.log(decodeString("3[a2[c]]")); // "accaccacc"\nconsole.log(decodeString("101[a2[c]]")); // "accaccacc"\n',B="/**\n * @param {number[]} stones\n * @return {number}\n */\nvar lastStoneWeight = function (stones) {\n  if (stones.length === 0) return 0;\n  if (stones.length === 1) return stones[0];\n\n  buildHeap(stones);\n  let numStones = stones.length;\n  while (numStones > 0) {\n    const left = 1;\n    const right = 2;\n    let xIdx = stones[left] > stones[right] ? left : right;\n    if (right >= stones.length) xIdx = left;\n\n    const y = stones[0];\n    const x = stones[xIdx];\n    if (x === y) {\n      stones[0] = 0;\n      stones[xIdx] = 0;\n      numStones -= 2;\n    }\n    if (x !== y) {\n      stones[0] -= stones[xIdx];\n      stones[xIdx] = 0;\n      numStones--;\n    }\n    heapify(stones, xIdx);\n    heapify(stones, 0);\n  }\n  return stones[0];\n};\n\n/**\n * Build a heap represented by an array.\n * @param {number[]} nums\n */\nfunction buildHeap(nums) {\n  // Total nodes\n  const N = nums.length;\n  // Last Non-leaf node index: (N/2)-1\n  const startIdx = Math.ceil(N / 2) - 1;\n\n  // heapify the nodes in reverse order level by level\n  for (let i = startIdx; i >= 0; i--) {\n    heapify(nums, i);\n  }\n}\n\n/**\n *\n * @param {number[]} nums\n * @param {number} rootIdx The index of the node to heapify\n */\nfunction heapify(nums, rootIdx) {\n  let largest = rootIdx;\n  const l = rootIdx * 2 + 1;\n  const r = rootIdx * 2 + 2;\n\n  if (l < nums.length && nums[l] > nums[largest]) {\n    largest = l;\n  }\n\n  if (r < nums.length && nums[r] > nums[largest]) {\n    largest = r;\n  }\n\n  // make the swap\n  if (largest !== rootIdx) {\n    const temp = nums[rootIdx];\n    nums[rootIdx] = nums[largest];\n    nums[largest] = temp;\n\n    heapify(nums, largest);\n  }\n}\n\nconsole.log(lastStoneWeight([9, 3, 2, 10])); // 0\nconsole.log(lastStoneWeight([1, 3])); // 2\nconsole.log(lastStoneWeight([1, 3, 5, 4, 6, 13, 10, 9, 8, 15, 17]));\nconsole.log(lastStoneWeight([2, 7, 4, 1, 8, 1])); // 1\nconsole.log(lastStoneWeight([1])); // 1\n",C='/**\n * @param {string[]} words\n * @param {number} k\n * @return {string[]}\n */\nvar topKFrequent = function (words, k) {\n  const freq = {};\n  words.forEach((word) => {\n    if (!freq[word]) freq[word] = 1;\n    else freq[word]++;\n  });\n  const results = Object.entries(freq).sort(\n    (a, b) => b[1] - a[1] || a[0].localeCompare(b[0])\n  );\n  return results.slice(0, k).map((el) => el[0]);\n};\n\nconsole.log(\n  topKFrequent(\n    ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"],\n    4\n  )\n);\n\nconsole.log(topKFrequent(["i", "love", "leetcode", "i", "love", "coding"], 2));\n',O={title:"LeetCode 75 Study Plan",authors:"xiaohai",tags:["study","algorithm"],description:"Follow LeetCode 75 Study Plan."},D=void 0,Z={permalink:"/blog/2022/07/09/leetcode-75",editUrl:"https://github.com/xiaohai-huang/learning-notes/tree/master/blog/2022/07-09-leetcode-75/index.mdx",source:"@site/blog/2022/07-09-leetcode-75/index.mdx",title:"LeetCode 75 Study Plan",description:"Follow LeetCode 75 Study Plan.",date:"2022-07-09T00:00:00.000Z",formattedDate:"9 July 2022",tags:[{label:"study",permalink:"/blog/tags/study"},{label:"algorithm",permalink:"/blog/tags/algorithm"}],readingTime:13.105,hasTruncateMarker:!0,authors:[{name:"Xiaohai Huang",title:"CS Student",url:"http://github.com/xiaohai-huang",imageURL:"https://github.com/xiaohai-huang.png",key:"xiaohai"}],frontMatter:{title:"LeetCode 75 Study Plan",authors:"xiaohai",tags:["study","algorithm"],description:"Follow LeetCode 75 Study Plan."},unlisted:!1,prevItem:{title:"Accessing a WSL2 Networking Apps From Your LAN",permalink:"/blog/2022/08/17/accessing-wsl2-networking-apps"},nextItem:{title:"Turn a Tablet Into a Secondary Monitor",permalink:"/blog/2022/05/22/tablet-as-monitor"}},E={authorsImageUrls:[void 0]},R=[{value:"Day 1 Prefix Sum",id:"day-1-prefix-sum",level:2},{value:"1480. Running Sum of 1d Array",id:"1480-running-sum-of-1d-array",level:3},{value:"724. Find Pivot Index",id:"724-find-pivot-index",level:3},{value:"Day 2 String",id:"day-2-string",level:2},{value:"205. Isomorphic Strings",id:"205-isomorphic-strings",level:3},{value:"392. Is Subsequence",id:"392-is-subsequence",level:3},{value:"Day 3 Linked List",id:"day-3-linked-list",level:2},{value:"21. Merge Two Sorted Lists",id:"21-merge-two-sorted-lists",level:3},{value:"206. Reverse Linked List",id:"206-reverse-linked-list",level:3},{value:"Day 4 Linked List",id:"day-4-linked-list",level:2},{value:"876. Middle of the Linked List",id:"876-middle-of-the-linked-list",level:3},{value:"142. Linked List Cycle II",id:"142-linked-list-cycle-ii",level:3},{value:"Day 5 Greedy",id:"day-5-greedy",level:2},{value:"121. Best Time to Buy and Sell Stock",id:"121-best-time-to-buy-and-sell-stock",level:3},{value:"409. Longest Palindrome",id:"409-longest-palindrome",level:3},{value:"Day 6 Tree",id:"day-6-tree",level:2},{value:"589. N-ary Tree Preorder Traversal",id:"589-n-ary-tree-preorder-traversal",level:3},{value:"102. Binary Tree Level Order Traversal",id:"102-binary-tree-level-order-traversal",level:3},{value:"Day 7 Binary Search",id:"day-7-binary-search",level:2},{value:"704. Binary Search",id:"704-binary-search",level:3},{value:"278. First Bad Version",id:"278-first-bad-version",level:3},{value:"Day 8 Binary Search Tree",id:"day-8-binary-search-tree",level:2},{value:"98. Validate Binary Search Tree",id:"98-validate-binary-search-tree",level:3},{value:"Solution 1",id:"solution-1",level:4},{value:"Solution 2",id:"solution-2",level:4},{value:"235. Lowest Common Ancestor of a Binary Search Tree",id:"235-lowest-common-ancestor-of-a-binary-search-tree",level:3},{value:"Solution 1",id:"solution-1-1",level:4},{value:"Solution 2",id:"solution-2-1",level:4},{value:"Day 9 Graph/BFS/DFS",id:"day-9-graphbfsdfs",level:2},{value:"733. Flood Fill",id:"733-flood-fill",level:3},{value:"200. Number of Islands",id:"200-number-of-islands",level:3},{value:"Solution",id:"solution",level:4},{value:"Day 10 Dynamic Programming",id:"day-10-dynamic-programming",level:2},{value:"509. Fibonacci Number",id:"509-fibonacci-number",level:3},{value:"70. Climbing Stairs",id:"70-climbing-stairs",level:3},{value:"Day 11 Dynamic Programming",id:"day-11-dynamic-programming",level:2},{value:"746. Min Cost Climbing Stairs",id:"746-min-cost-climbing-stairs",level:3},{value:"62. Unique Paths",id:"62-unique-paths",level:3},{value:"Day 12 Sliding Window/Two Pointer",id:"day-12-sliding-windowtwo-pointer",level:2},{value:"438. Find All Anagrams in a String",id:"438-find-all-anagrams-in-a-string",level:3},{value:"424. Longest Repeating Character Replacement",id:"424-longest-repeating-character-replacement",level:3},{value:"Day 13 Hashmap",id:"day-13-hashmap",level:2},{value:"299. Bulls and Cows",id:"299-bulls-and-cows",level:3},{value:"Day 14 Stack",id:"day-14-stack",level:2},{value:"394. Decode String",id:"394-decode-string",level:3},{value:"Day 15 Heap",id:"day-15-heap",level:2},{value:"1046. Last Stone Weight",id:"1046-last-stone-weight",level:3},{value:"692. Top K Frequent Words",id:"692-top-k-frequent-words",level:3}];function M(e){const n=Object.assign({blockquote:"blockquote",p:"p",h2:"h2",h3:"h3",a:"a",admonition:"admonition",code:"code",ul:"ul",li:"li",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",img:"img",pre:"pre",em:"em",h4:"h4",span:"span",math:"math",semantics:"semantics",mrow:"mrow",mo:"mo",mi:"mi",annotation:"annotation",ol:"ol"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["This study plan is for those who want to prepare for technical interviews but are uncertain which problems they should focus on. The problems have been carefully curated so that levels 1 and 2 will guide beginner and intermediate users through problems that cover the data structures and algorithms necessary to succeed in interviews with most mid-tier companies. While level 3 provides material to help users whose targets are top-tier companies.\n-- ",(0,r.jsx)("cite",{children:(0,r.jsx)("a",{href:"https://leetcode.com/study-plan/leetcode-75",target:"_blank",children:"LeetCode"})})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"day-1-prefix-sum",children:"Day 1 Prefix Sum"}),"\n",(0,r.jsx)(n.h3,{id:"1480-running-sum-of-1d-array",children:"1480. Running Sum of 1d Array"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/running-sum-of-1d-array/",children:"https://leetcode.com/problems/running-sum-of-1d-array"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:l}),"\n",(0,r.jsx)(n.h3,{id:"724-find-pivot-index",children:"724. Find Pivot Index"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/find-pivot-index/",children:"https://leetcode.com/problems/find-pivot-index"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["At a given index ",(0,r.jsx)(n.code,{children:"i"}),", how do I get the value of ",(0,r.jsx)(n.code,{children:"leftSum"})," and ",(0,r.jsx)(n.code,{children:"rightSum"}),"?"]}),(0,r.jsx)(n.p,{children:"Ans:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"leftSum"})," of ",(0,r.jsx)(n.strong,{children:"i"}),"-th element can be computed by ",(0,r.jsx)(n.strong,{children:"summing"})," up all the values on the left of the ",(0,r.jsx)(n.strong,{children:"i"}),"-th element."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rightSum"})," of ",(0,r.jsx)(n.strong,{children:"i"}),"-th element is equal to the sum of the array ",(0,r.jsx)(n.strong,{children:"minus"})," the value of the current element ",(0,r.jsx)(n.strong,{children:"and"})," ",(0,r.jsx)(n.code,{children:"leftSum"}),"."]}),"\n"]})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:a}),"\n",(0,r.jsx)(n.h2,{id:"day-2-string",children:"Day 2 String"}),"\n",(0,r.jsx)(n.h3,{id:"205-isomorphic-strings",children:"205. Isomorphic Strings"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/isomorphic-strings/",children:"https://leetcode.com/problems/isomorphic-strings"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:"Given two strings s and t, determine if they are isomorphic."}),(0,r.jsx)(n.p,{children:"Two strings s and t are isomorphic if the characters in s can be replaced to get t."}),(0,r.jsx)(n.p,{children:"All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself."})]}),"\n",(0,r.jsxs)(n.p,{children:["Should pay more attention on the last paragraph of the requirement. A character can only be mapped to one character. Therefore, create a set to store the ",(0,r.jsx)(n.code,{children:"values"}),". i.e. ",(0,r.jsx)(n.strong,{children:"one-to-one"})," relationship."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{align:"center",children:"input"}),(0,r.jsx)(n.th,{children:"map"}),(0,r.jsx)(n.th,{children:"result"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:"egg -> add"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{e : a, g : d}"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:"badc -> baba"}),(0,r.jsx)(n.td,{children:(0,r.jsxs)("ol",{children:[(0,r.jsx)("li",{children:"b -> b"}),(0,r.jsx)("li",{children:"a -> a"}),(0,r.jsx)("li",{children:"d -> b"}),(0,r.jsx)("li",{children:"c -> a"})]})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:['For "badc -> baba", it has two characters that map to b (',(0,r.jsx)(n.strong,{children:"b"})," and ",(0,r.jsx)(n.strong,{children:"d"}),") so it is not isomorphic."]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:c}),"\n",(0,r.jsx)(n.h3,{id:"392-is-subsequence",children:"392. Is Subsequence"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/is-subsequence/",children:"https://leetcode.com/problems/is-subsequence"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:"Given two strings s and t, return true if s is a subsequence of t, or false otherwise."}),(0,r.jsx)(n.p,{children:'A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).'})]}),"\n",(0,r.jsxs)(n.p,{children:["A simple example ",(0,r.jsx)(n.code,{children:'isSubsequence("bc", "abagdc")'})]}),"\n",(0,r.jsxs)(n.p,{children:["First, check if ",(0,r.jsx)(n.code,{children:"b"})," in the string if it does exist then check the ",(0,r.jsx)(n.strong,{children:"remaining characters"})," to see if ",(0,r.jsx)(n.code,{children:"c"})," exist."]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:d}),"\n",(0,r.jsx)(n.h2,{id:"day-3-linked-list",children:"Day 3 Linked List"}),"\n",(0,r.jsx)(n.h3,{id:"21-merge-two-sorted-lists",children:"21. Merge Two Sorted Lists"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/merge-two-sorted-lists/",children:"https://leetcode.com/problems/merge-two-sorted-lists"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:h}),"\n",(0,r.jsx)(n.h3,{id:"206-reverse-linked-list",children:"206. Reverse Linked List"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/reverse-linked-list/",children:"https://leetcode.com/problems/reverse-linked-list"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg",alt:"reverse linked list"})}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["Change each node's ",(0,r.jsx)(n.strong,{children:"next"})," pointer to its left node."]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"null <- 1 <- 2 <- 3"})})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:u}),"\n",(0,r.jsx)(n.h2,{id:"day-4-linked-list",children:"Day 4 Linked List"}),"\n",(0,r.jsx)(n.h3,{id:"876-middle-of-the-linked-list",children:"876. Middle of the Linked List"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/middle-of-the-linked-list/",children:"https://leetcode.com/problems/middle-of-the-linked-list"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:"Given the head of a singly linked list, return the middle node of the linked list."}),(0,r.jsx)(n.p,{children:"If there are two middle nodes, return the second middle node."}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 1"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg",alt:"example 1"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.\n"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 2"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg",alt:"example 2"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.\n"})})]}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Fast and Slow Pointer"})}),(0,r.jsxs)(n.p,{children:["When traversing the list with a pointer slow, make another pointer fast that traverses ",(0,r.jsx)(n.strong,{children:"twice as fast"}),"."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"slow = slow.next"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"fast = fast.next.next"})}),"\n"]}),(0,r.jsx)(n.p,{children:"When fast reaches the end of the list, slow must be in the middle."})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:m}),"\n",(0,r.jsx)(n.h3,{id:"142-linked-list-cycle-ii",children:"142. Linked List Cycle II"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/linked-list-cycle-ii/",children:"https://leetcode.com/problems/linked-list-cycle-ii"})]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return ",(0,r.jsx)(n.code,{children:"null"}),"."]})}),"\n",(0,r.jsx)(i.Z,{run:!1,children:p}),"\n",(0,r.jsx)(n.h2,{id:"day-5-greedy",children:"Day 5 Greedy"}),"\n",(0,r.jsx)(n.h3,{id:"121-best-time-to-buy-and-sell-stock",children:"121. Best Time to Buy and Sell Stock"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",children:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock"})]}),"\n",(0,r.jsx)(n.p,{children:"Two import information to keep track of:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"min price"}),"\n",(0,r.jsx)(n.li,{children:"max profit"}),"\n"]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:g}),"\n",(0,r.jsx)(n.h3,{id:"409-longest-palindrome",children:"409. Longest Palindrome"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/longest-palindrome/",children:"https://leetcode.com/problems/longest-palindrome"})]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Given a string s which consists of lowercase or uppercase letters,\nreturn the length of the ",(0,r.jsx)(n.strong,{children:"longest palindrome"})," that ",(0,r.jsx)(n.strong,{children:"can be built"})," with those letters."]})}),"\n",(0,r.jsxs)(n.p,{children:["Imagine we build a palindrome string, it will have as many as ",(0,r.jsx)(n.em,{children:"partnered letters"})," as possible,\nplus possibly a unique ",(0,r.jsx)(n.strong,{children:"center"})," character."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If the number of occurrences of a letter is ",(0,r.jsx)(n.strong,{children:"even"}),", add the count to the total length of the palindrome."]}),"\n",(0,r.jsxs)(n.li,{children:["If the number of occurrences of a letter is ",(0,r.jsx)(n.strong,{children:"odd"}),", subtract the count by 1 and add it to the total length of the palindrome."]}),"\n",(0,r.jsxs)(n.li,{children:["If the palindrome haven't added a unique character to the center, add 1 to the length of the palindrome if a character with the number of occurrences equals 1 is found.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["e.g. ",(0,r.jsx)(n.code,{children:"{b : 2, f : 1, c : 1}"}),", ",(0,r.jsx)(n.code,{children:"f"})," can be added to the center of the palindrome and it is the only character that is unique."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"We can only insert 1 unique character and it has to be at the center."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"aa"}),", ",(0,r.jsx)(n.code,{children:"abba"})," are palindrome strings. The center of the palindrome can have 2 characters."]}),"\n"]})}),"\n",(0,r.jsx)(i.Z,{run:!1,children:x}),"\n",(0,r.jsx)(n.h2,{id:"day-6-tree",children:"Day 6 Tree"}),"\n",(0,r.jsx)(n.h3,{id:"589-n-ary-tree-preorder-traversal",children:"589. N-ary Tree Preorder Traversal"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/n-ary-tree-preorder-traversal/",children:"https://leetcode.com/problems/n-ary-tree-preorder-traversal"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png",alt:"example 1"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Input: root = ",(0,r.jsx)(n.code,{children:"[1,null,3,2,4,null,5,6]"})]}),"\n",(0,r.jsxs)(n.li,{children:["Output: ",(0,r.jsx)(n.code,{children:"[1,3,5,6,2,4]"})]}),"\n"]})]}),"\n",(0,r.jsxs)(n.p,{children:["Pre-order traversal is ",(0,r.jsx)(n.code,{children:"root -> left -> right"}),"."]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:f}),"\n",(0,r.jsx)(n.h3,{id:"102-binary-tree-level-order-traversal",children:"102. Binary Tree Level Order Traversal"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"https://leetcode.com/problems/binary-tree-level-order-traversal"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg",alt:"level order traversal example"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Input: root = ",(0,r.jsx)(n.code,{children:"[3,9,20,null,null,15,7]"})]}),"\n",(0,r.jsxs)(n.li,{children:["Output: ",(0,r.jsx)(n.code,{children:"[[3],[9,20],[15,7]]"})]}),"\n"]})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Enqueue all nodes of a level."}),"\n",(0,r.jsxs)(n.li,{children:["Process the tree level-by-level.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Enqueue all children of each node in the current level."}),"\n",(0,r.jsx)(n.li,{children:"How to process level-by-level? This is achieved by checking the number of nodes in a level before processing a level."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:j}),"\n",(0,r.jsx)(n.h2,{id:"day-7-binary-search",children:"Day 7 Binary Search"}),"\n",(0,r.jsx)(n.h3,{id:"704-binary-search",children:"704. Binary Search"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-search/",children:"https://leetcode.com/problems/binary-search"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["Given an array of integers ",(0,r.jsx)(n.code,{children:"nums"})," which is sorted in ",(0,r.jsx)(n.strong,{children:"ascending order"}),", and an integer ",(0,r.jsx)(n.code,{children:"target"}),",\nwrite a function to search ",(0,r.jsx)(n.code,{children:"target"})," in ",(0,r.jsx)(n.code,{children:"nums"}),".\nIf ",(0,r.jsx)(n.code,{children:"target"})," exists, then return its index. Otherwise, return ",(0,r.jsx)(n.code,{children:"-1"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n"})})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:v}),"\n",(0,r.jsx)(n.h3,{id:"278-first-bad-version",children:"278. First Bad Version"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/first-bad-version/",children:"https://leetcode.com/problems/first-bad-version"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:b}),"\n",(0,r.jsx)(n.h2,{id:"day-8-binary-search-tree",children:"Day 8 Binary Search Tree"}),"\n",(0,r.jsx)(n.h3,{id:"98-validate-binary-search-tree",children:"98. Validate Binary Search Tree"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/validate-binary-search-tree/",children:"https://leetcode.com/problems/validate-binary-search-tree"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["Given the ",(0,r.jsx)(n.code,{children:"root"})," of a binary tree, determine if it is a valid ",(0,r.jsx)(n.em,{children:"binary search tree (BST)"}),"."]}),(0,r.jsxs)(n.p,{children:["A valid ",(0,r.jsx)(n.strong,{children:"BST"})," is defined as follows:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The left subtree of a node contains only nodes with keys ",(0,r.jsx)(n.strong,{children:"less than"})," the node's key."]}),"\n",(0,r.jsxs)(n.li,{children:["The right subtree of a node contains only nodes with keys ",(0,r.jsx)(n.strong,{children:"greater than"})," the node's key."]}),"\n",(0,r.jsx)(n.li,{children:"Both the left and right subtrees must also be binary search trees."}),"\n"]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 1"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg",alt:"example 1"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: root = [2,1,3]\nOutput: true\n"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg",alt:"example 2"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n"})})]}),"\n",(0,r.jsx)(n.h4,{id:"solution-1",children:"Solution 1"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/validate-binary-search-tree/discuss/783930/Easy-to-understand-2-lines-solution!-O(n)-with-Examples-and-Explanation-JavaScript",children:"solution"})}),"\n",(0,r.jsxs)(n.p,{children:["Main idea: Check if the current node's value is within the ",(0,r.jsx)(n.strong,{children:"valid range"})," (",(0,r.jsx)(n.code,{children:"floor"}),"/",(0,r.jsx)(n.code,{children:"ceiling"}),")."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Base case: ",(0,r.jsx)(n.code,{children:"root=null"}),", the tree is a valid binary search tree."]}),"\n",(0,r.jsxs)(n.li,{children:["Recursively check the valid range of each node ",(0,r.jsx)(n.code,{children:"floor < root.val < ceiling"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Initially, the valid range of the ",(0,r.jsx)(n.code,{children:"root"})," node is ",(0,r.jsx)(n.span,{className:"math math-inline",children:(0,r.jsxs)(n.span,{className:"katex",children:[(0,r.jsx)(n.span,{className:"katex-mathml",children:(0,r.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(n.semantics,{children:[(0,r.jsxs)(n.mrow,{children:[(0,r.jsx)(n.mo,{stretchy:"false",children:"["}),(0,r.jsx)(n.mi,{mathvariant:"normal",children:"\u221e"}),(0,r.jsx)(n.mo,{separator:"true",children:","}),(0,r.jsx)(n.mo,{children:"+"}),(0,r.jsx)(n.mi,{mathvariant:"normal",children:"\u221e"}),(0,r.jsx)(n.mo,{stretchy:"false",children:"]"})]}),(0,r.jsx)(n.annotation,{encoding:"application/x-tex",children:"[\\infty, +\\infty]"})]})})}),(0,r.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,r.jsxs)(n.span,{className:"base",children:[(0,r.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.jsx)(n.span,{className:"mopen",children:"["}),(0,r.jsx)(n.span,{className:"mord",children:"\u221e"}),(0,r.jsx)(n.span,{className:"mpunct",children:","}),(0,r.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.jsx)(n.span,{className:"mord",children:"+"}),(0,r.jsx)(n.span,{className:"mord",children:"\u221e"}),(0,r.jsx)(n.span,{className:"mclose",children:"]"})]})})]})})]}),"\n",(0,r.jsxs)(n.li,{children:["After visiting the ",(0,r.jsx)(n.code,{children:"root"}),", we start restricting the ",(0,r.jsx)(n.strong,{children:"valid range"}),".","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If we move to the left child, the ",(0,r.jsx)(n.code,{children:"ceiling"})," of the left child will be updated to ",(0,r.jsx)(n.code,{children:"root.val"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If we move to the right child, the ",(0,r.jsx)(n.code,{children:"floor"})," of the right child will be updated to ",(0,r.jsx)(n.code,{children:"root.val"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var isValidBST = function (root, floor = -Infinity, ceiling = Infinity) {\n  if (!root) return true;\n\n  if (!(floor < root.val && root.val < ceiling)) {\n    return false;\n  }\n\n  return (\n    isValidBST(root.left, floor, root.val) &&\n    isValidBST(root.right, root.val, ceiling)\n  );\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"solution-2",children:"Solution 2"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.strong,{children:"in-order traversal"})," to collect all the ",(0,r.jsx)(n.code,{children:"values"})," of a binary search tree,\nthen check if the ",(0,r.jsx)(n.code,{children:"values"})," are in the correct order (ascending)."]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:y}),"\n",(0,r.jsx)(n.h3,{id:"235-lowest-common-ancestor-of-a-binary-search-tree",children:"235. Lowest Common Ancestor of a Binary Search Tree"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",children:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:"Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST."}),(0,r.jsxs)(n.p,{children:["\u201cThe lowest common ancestor is defined between two nodes ",(0,r.jsx)(n.code,{children:"p"})," and ",(0,r.jsx)(n.code,{children:"q"})," as the lowest node in ",(0,r.jsx)(n.code,{children:"Tree"}),"\nthat has both ",(0,r.jsx)(n.code,{children:"p"})," and ",(0,r.jsx)(n.code,{children:"q"})," as descendants (where we allow a node to be a descendant of itself).\u201d"]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 1:"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png",alt:"eg 1"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 2:"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png",alt:"eg 2"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2,\nsince a node can be a descendant of itself according to the LCA definition.\n"})})]}),"\n",(0,r.jsx)(n.h4,{id:"solution-1-1",children:"Solution 1"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Level order traversal, ",(0,r.jsx)(n.code,{children:"callback(node, levelNum)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Search for the ",(0,r.jsx)(n.code,{children:"target nodes"})," based on the current node.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Found target nodes - update the lowest common ancestor"}),"\n",(0,r.jsx)(n.li,{children:"Not found - break"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"solution-2-1",children:"Solution 2"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/235.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree.jpg",alt:"solution"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If both ",(0,r.jsx)(n.code,{children:"target nodes"})," are ",(0,r.jsx)(n.strong,{children:"less"})," than the ",(0,r.jsx)(n.code,{children:"current node"}),", pick the left child as the potential common ancestor."]}),"\n",(0,r.jsxs)(n.li,{children:["If both ",(0,r.jsx)(n.code,{children:"target nodes"})," are ",(0,r.jsx)(n.strong,{children:"greater"})," than the ",(0,r.jsx)(n.code,{children:"current node"}),", pick the right child as the potential common ancestor."]}),"\n",(0,r.jsxs)(n.li,{children:["If the ",(0,r.jsx)(n.code,{children:"current node"})," is causing a ",(0,r.jsx)(n.strong,{children:"diverging"}),", return the current node.\ne.g. ",(0,r.jsx)(n.strong,{children:"0"})," and ",(0,r.jsx)(n.strong,{children:"5"})," go for different subtrees at node ",(0,r.jsx)(n.strong,{children:"2"}),". So node ",(0,r.jsx)(n.strong,{children:"2"})," is the lowest common ancestor."]}),"\n"]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["There are some special ",(0,r.jsx)(n.strong,{children:"constraints"}),":"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["All ",(0,r.jsx)(n.code,{children:"Node.val"})," are unique."]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"p != q"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"p"})," and ",(0,r.jsx)(n.code,{children:"q"})," will exist in the ",(0,r.jsx)(n.strong,{children:"BST"}),"."]}),"\n"]})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:w}),"\n",(0,r.jsx)(n.h2,{id:"day-9-graphbfsdfs",children:"Day 9 Graph/BFS/DFS"}),"\n",(0,r.jsx)(n.h3,{id:"733-flood-fill",children:"733. Flood Fill"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Array"}),"\n",(0,r.jsx)(n.li,{children:"Depth-First Search"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/flood-fill/",children:"https://leetcode.com/problems/flood-fill"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["You are given three integers ",(0,r.jsx)(n.code,{children:"sr"}),", ",(0,r.jsx)(n.code,{children:"sc"}),", and ",(0,r.jsx)(n.code,{children:"color"}),".\nYou should perform a flood fill on the image starting from the pixel ",(0,r.jsx)(n.code,{children:"image[sr][sc]"}),"."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"sr: starting row"}),"\n",(0,r.jsx)(n.li,{children:"sc: starting col"}),"\n"]}),(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["To perform a ",(0,r.jsx)(n.strong,{children:"flood"})," fill, consider the starting pixel, plus any pixels connected ",(0,r.jsx)(n.strong,{children:"4-directionally"})," to the ",(0,r.jsx)(n.strong,{children:"starting pixel"})," of the ",(0,r.jsx)(n.em,{children:"same color"})," as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color."]}),"\n"]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 1:"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg",alt:"example 1"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\n"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 2:"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\n"})})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:S}),"\n",(0,r.jsx)(n.h3,{id:"200-number-of-islands",children:"200. Number of Islands"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Array"}),"\n",(0,r.jsx)(n.li,{children:"Depth-First Search"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands/",children:"https://leetcode.com/problems/number-of-islands"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["Given an ",(0,r.jsx)(n.code,{children:"m x n"})," 2D binary grid grid which represents a map of ",(0,r.jsx)(n.code,{children:"'1'"}),"s (land) and ",(0,r.jsx)(n.code,{children:"'0'"}),"s (water), return the number of islands."]}),(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.strong,{children:"island"})," is surrounded by water and is formed by connecting adjacent lands ",(0,r.jsx)(n.strong,{children:"horizontally"})," or ",(0,r.jsx)(n.strong,{children:"vertically"}),". You may assume ",(0,r.jsx)(n.strong,{children:"all four edges"})," of the grid are all surrounded by water."]})]}),"\n",(0,r.jsx)(n.h4,{id:"solution",children:"Solution"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands/discuss/56340/Python-Simple-DFS-Solution",children:"https://leetcode.com/problems/number-of-islands/discuss/56340/Python-Simple-DFS-Solution"})}),"\n",(0,r.jsxs)(n.p,{children:["Iterate through each of the cell and if it is a land, do ",(0,r.jsx)(n.code,{children:"DFS"})," to mark the all adjacent lands, then increment the counter by 1."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def numIslands(self, grid):\n    if not grid:\n        return 0\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                self.dfs(grid, i, j)\n                count += 1\n    return count\n\ndef dfs(self, grid, i, j):\n    if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\n        return\n    grid[i][j] = '#' # mark/exclude the entire land, only count it once in the main loop\n    self.dfs(grid, i+1, j)\n    self.dfs(grid, i-1, j)\n    self.dfs(grid, i, j+1)\n    self.dfs(grid, i, j-1)\n"})}),"\n",(0,r.jsx)(i.Z,{run:!1,children:N}),"\n",(0,r.jsx)(n.h2,{id:"day-10-dynamic-programming",children:"Day 10 Dynamic Programming"}),"\n",(0,r.jsx)(n.h3,{id:"509-fibonacci-number",children:"509. Fibonacci Number"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/fibonacci-number/",children:"https://leetcode.com/problems/fibonacci-number"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:k}),"\n",(0,r.jsx)(n.h3,{id:"70-climbing-stairs",children:"70. Climbing Stairs"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/climbing-stairs/",children:"https://leetcode.com/problems/climbing-stairs"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def climbStairs(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return climbStairs(n-1) + climbStairs(n-2)\n"})}),"\n",(0,r.jsx)(i.Z,{run:!1,children:q}),"\n",(0,r.jsx)(n.h2,{id:"day-11-dynamic-programming",children:"Day 11 Dynamic Programming"}),"\n",(0,r.jsx)(o.Z,{src:"https://www.youtube.com/embed/oBt53YbR9Kk",caption:"Dynamic Programming - Learn to Solve Algorithmic Problems"}),"\n",(0,r.jsx)(n.h3,{id:"746-min-cost-climbing-stairs",children:"746. Min Cost Climbing Stairs"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/min-cost-climbing-stairs/",children:"https://leetcode.com/problems/min-cost-climbing-stairs"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:T}),"\n",(0,r.jsx)(n.h3,{id:"62-unique-paths",children:"62. Unique Paths"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/unique-paths/",children:"https://leetcode.com/problems/unique-paths"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:I}),"\n",(0,r.jsx)(n.h2,{id:"day-12-sliding-windowtwo-pointer",children:"Day 12 Sliding Window/Two Pointer"}),"\n",(0,r.jsx)(n.h3,{id:"438-find-all-anagrams-in-a-string",children:"438. Find All Anagrams in a String"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/find-all-anagrams-in-a-string/",children:"https://leetcode.com/problems/find-all-anagrams-in-a-string"})]}),"\n",(0,r.jsxs)(n.p,{children:["Use sliding window technique, which is inspired by this ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/2052920/Clean-JavaScript",children:"https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/2052920/Clean-JavaScript"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:L}),"\n",(0,r.jsx)(n.h3,{id:"424-longest-repeating-character-replacement",children:"424. Longest Repeating Character Replacement"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/longest-repeating-character-replacement/",children:"https://leetcode.com/problems/longest-repeating-character-replacement"})]}),"\n",(0,r.jsxs)(n.p,{children:["Inspired by this video: ",(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=gqXU1UyA8pk",children:"https://www.youtube.com/watch?v=gqXU1UyA8pk"})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:A}),"\n",(0,r.jsx)(n.h2,{id:"day-13-hashmap",children:"Day 13 Hashmap"}),"\n",(0,r.jsx)(n.h3,{id:"299-bulls-and-cows",children:"299. Bulls and Cows"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/bulls-and-cows",children:"https://leetcode.com/problems/bulls-and-cows"})]}),"\n",(0,r.jsxs)(n.p,{children:["Given the secret number ",(0,r.jsx)(n.code,{children:"secret"})," and your friend's ",(0,r.jsx)(n.code,{children:"guess"}),", return the ",(0,r.jsx)(n.strong,{children:"hint"})," for your friend's guess."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'The number of "bulls", which are digits in the guess that are in the correct position.'}),"\n",(0,r.jsx)(n.li,{children:'The number of "cows", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.'}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Input: secret = "1807", guess = "7810"\nOutput: "1A3B"\nExplanation: Bulls are connected with a \'|\' and cows are underlined:\n"1807"\n  |\n"7810"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Find the value of ",(0,r.jsx)(n.code,{children:"bulls"})," and then find the value of ",(0,r.jsx)(n.code,{children:"guess"}),"."]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:P}),"\n",(0,r.jsx)(n.h2,{id:"day-14-stack",children:"Day 14 Stack"}),"\n",(0,r.jsx)(n.h3,{id:"394-decode-string",children:"394. Decode String"}),"\n",(0,r.jsxs)(n.p,{children:["src: ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/decode-string/",children:"https://leetcode.com/problems/decode-string"})]}),"\n",(0,r.jsxs)(n.p,{children:["The encoding rule is: ",(0,r.jsx)(n.code,{children:"k[encoded_string]"}),", where the encoded_string inside the square brackets is being repeated exactly ",(0,r.jsx)(n.code,{children:"k"})," times. Note that ",(0,r.jsx)(n.code,{children:"k"})," is guaranteed to be a positive integer."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/",children:"check for balanced brackets"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Inspired by NeetCode ",(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=qB0zZpBJlh8",children:"https://www.youtube.com/watch?v=qB0zZpBJlh8"})]}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"3[a2[c]]"'})}),(0,r.jsxs)(n.p,{children:["Push every ",(0,r.jsx)(n.code,{children:"char"})," into the ",(0,r.jsx)(n.code,{children:"stack"})," unless the ",(0,r.jsx)(n.code,{children:"char"})," is ",(0,r.jsx)(n.code,{children:"]"}),"."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"]"})," is found, process the content inside the brackets, and push the processed result to the stack."]}),"\n"]})]}),"\n",(0,r.jsx)(i.Z,{run:!1,children:F}),"\n",(0,r.jsx)(n.h2,{id:"day-15-heap",children:"Day 15 Heap"}),"\n",(0,r.jsx)(n.h3,{id:"1046-last-stone-weight",children:"1046. Last Stone Weight"}),"\n",(0,r.jsxs)(n.p,{children:["You are given an array of integers stones where ",(0,r.jsx)(n.code,{children:" stones[i]"})," is the weight of the ",(0,r.jsx)(n.code,{children:"ith"})," stone."]}),"\n",(0,r.jsxs)(n.p,{children:["Pick the ",(0,r.jsx)(n.strong,{children:"heaviest"})," two stones. Suppose the heaviest two stones have weights ",(0,r.jsx)(n.code,{children:"x`` and "}),"y",(0,r.jsx)(n.code,{children:" with `x <= y"}),". The result of this smash is:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"x=y"}),", both stones are destroyed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"x<y"}),", the stone of weight ",(0,r.jsx)(n.code,{children:"x"})," is destroyed, and the stone of weight ",(0,r.jsx)(n.code,{children:"y"})," has a new weight ",(0,r.jsx)(n.code,{children:"y-x"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"At the end of the game, there is at most one stone left. (could be zero stone left)."}),"\n",(0,r.jsx)(n.p,{children:"Return the weight of the last stone, if there are no stones left, return 0."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Push all elements into a max heap."}),"\n",(0,r.jsx)(n.li,{children:"Pop the largest two stones, and do the smash."}),"\n",(0,r.jsx)(n.li,{children:"Push the remaining stone after smashing into the max heap."}),"\n"]})}),"\n",(0,r.jsx)(i.Z,{run:!1,children:B}),"\n",(0,r.jsx)(n.h3,{id:"692-top-k-frequent-words",children:"692. Top K Frequent Words"}),"\n",(0,r.jsxs)(n.p,{children:["Given an array of strings words and an integer ",(0,r.jsx)(n.code,{children:"k"}),", return the ",(0,r.jsx)(n.code,{children:"k"})," most frequent strings."]}),"\n",(0,r.jsx)(n.p,{children:"Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order."}),"\n",(0,r.jsx)(i.Z,{run:!1,children:C})]})}const _=function(e={}){const{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(M,e)})):M(e)}},91262:(e,n,t)=>{"use strict";t.d(n,{Z:()=>i});t(67294);var r=t(72389),s=t(85893);function i(e){let{children:n,fallback:t}=e;return(0,r.Z)()?(0,s.jsx)(s.Fragment,{children:n?.()}):t??null}},61830:(e,n,t)=>{"use strict";t.d(n,{Z:()=>N});var r=t(67294),s=t(91262),i=t(10412),o=t(40460),l=t.n(o),a=t(70631),c=t.n(a),d=t(87410),h=t(71418),u=t(86010);const m=/\r\n|\r|\n/,p=e=>{0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},g=(e,n)=>{const t=e.length;return t>0&&e[t-1]===n?e:e.concat(n)},x=e=>{const n=[[]],t=[e],r=[0],s=[e.length];let i=0,o=0,l=[];const a=[l];for(;o>-1;){for(;(i=r[o]++)<s[o];){let e,c=n[o];const d=t[o][i];if("string"==typeof d?(c=o>0?c:["plain"],e=d):(c=g(c,d.type),d.alias&&(c=g(c,d.alias)),e=d.content),"string"!=typeof e){o++,n.push(c),t.push(e),r.push(0),s.push(e.length);continue}const h=e.split(m),u=h.length;l.push({types:c,content:h[0]});for(let n=1;n<u;n++)p(l),a.push(l=[]),l.push({types:c,content:h[n]})}o--,n.pop(),t.pop(),r.pop(),s.pop()}return p(l),a},f=(e,n)=>{const{plain:t}=e,r=e.styles.reduce(((e,t)=>{const{languages:r,style:s}=t;return r&&!r.includes(n)||t.types.forEach((n=>{const t={...e[n],...s};e[n]=t})),e}),{});return r.root=t,r.plain={...t,backgroundColor:void 0},r};var j=t(85893);const v=f(h.Z,"javascript");i.Z.canUseDOM&&((void 0!==t.g?t.g:window).Prism=d.Z);const b=e=>{let n="";return e.forEach(((e,t)=>{let r=e;e!==window&&(r=c()(e)),n+=`${t+1}:  ${r}\n`})),n},y=e=>{let{key:n,className:t,style:r,line:s,...i}=e;const o={...i,className:"token-line",style:void 0,key:void 0};return void 0!==v&&(o.style=v.plain),void 0!==r&&(o.style=void 0!==o.style?{...o.style,...r}:r),void 0!==n&&(o.key=n),t&&(o.className+=` ${t}`),o},w=e=>{let{types:n,empty:t}=e;const r=n.length;if(void 0===v)return;if(1===r&&"plain"===n[0])return t?{display:"inline-block"}:void 0;if(1===r&&!t)return v[n[0]];const s=t?{display:"inline-block"}:{},i=n.map((e=>v[e]));return Object.assign(s,...i)},S=e=>{let{key:n,className:t,style:r,token:s,...i}=e;const o={...i,className:`token ${s.types.join(" ")}`,children:s.content,style:w(s),key:void 0};return void 0!==r&&(o.style=void 0!==o.style?{...o.style,...r}:r),void 0!==n&&(o.key=n),t&&(o.className+=` ${t}`),o};function N(e){let{children:n="",title:t="",run:i=!0}=e;const[o,a]=(0,r.useState)(n),[c,m]=(0,r.useState)(""),p=()=>{m("");const e=`\n    const __results=[];\n        \n    try{\n      (()=>{\n        ${o}\n      })();\n    }catch(err){\n      return {results: __results, err};\n    }\n      \n    return {results: __results};`.replaceAll("console.log","__results.push");console.log(`var output =  (()=>{\n      ${e}\n    })() `);try{const{results:n,err:t}=new Function(e)();m(b(t?[...n,t]:n))}catch(n){m(b([n]))}};return(0,r.useEffect)((()=>{i&&p()}),[i]),(0,j.jsxs)("section",{className:"js-live-editor margin-bottom--md",children:[(0,j.jsx)("i",{children:t}),(0,j.jsx)("div",{className:"shadow--md thin-scrollbar",children:(0,j.jsx)(l(),{className:"editor",textareaClassName:"codeArea",style:h.Z.plain,padding:10,value:o,onValueChange:e=>a(e),highlight:e=>x(d.Z.tokenize(e,d.Z.languages.javascript,"javascript")).map(((e,n)=>(0,j.jsxs)("div",{...y({line:e}),children:[(0,j.jsx)("span",{className:"editorLineNumber",children:n+1}),e.map(((e,n)=>(0,j.jsx)("span",{...S({token:e})},n)))]},n)))})}),(0,j.jsx)("button",{className:"button button--primary margin-top--md margin-right--xs",onClick:p,children:"Run"}),(0,j.jsx)("button",{className:"button button--secondary margin-top--md",onClick:()=>{a(n),m("")},children:"Reset"}),(0,j.jsx)("div",{className:(0,u.Z)("outputArea","shadow--md","margin-top--md","padding--sm"),children:(0,j.jsx)(s.Z,{fallback:(0,j.jsx)(j.Fragment,{children:" "}),children:()=>(0,j.jsx)(j.Fragment,{children:""===c?" ":c})})})]})}},72796:(e,n,t)=>{"use strict";t.d(n,{Z:()=>s});t(67294);var r=t(85893);const s=function(e){let{src:n="",caption:t=""}=e;return(0,r.jsxs)("div",{children:[(0,r.jsx)("iframe",{style:{width:"100%",height:"350px"},src:n,title:"YouTube video player",frameBorder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowFullScreen:!0}),t&&(0,r.jsx)("p",{style:{textAlign:"center"},children:t})]})}},24654:()=>{},11151:(e,n,t)=>{"use strict";t.d(n,{Zo:()=>l,ah:()=>i});var r=t(67294);const s=r.createContext({});function i(e){const n=r.useContext(s);return r.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const o={};function l({components:e,children:n,disableParentContext:t}){let l;return l=t?"function"==typeof e?e({}):e||o:i(e),r.createElement(s.Provider,{value:l},n)}}}]);