"use strict";(self.webpackChunkbj_blog=self.webpackChunkbj_blog||[]).push([[5894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"regular-expressions","metadata":{"permalink":"/blog/regular-expressions","source":"@site/blog/2024-05-16-regular-expressions.md","title":"Regular expressions","description":"- Consists of a sequence of atoms (an atom is a literal - letter, digit, special character)","date":"2024-05-16T00:00:00.000Z","formattedDate":"May 16, 2024","tags":[{"label":"others","permalink":"/blog/tags/others"}],"readingTime":2.865,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"regular-expressions","title":"Regular expressions","authors":"bjab","tags":["others"]},"nextItem":{"title":"Calculating the memory usage by a String in JVM - JOL Footprint","permalink":"/blog/string-in-jvm-memory"}},"content":"- Consists of a sequence of atoms (an atom is a literal - letter, digit, special character)\\r\\n- Letters are case sensitive\\r\\n- You can test regexes in online tools like: https://regex101.com/\\r\\n\x3c!-- truncate --\x3e\\r\\n# Quantifiers\\r\\n\\r\\nThe quantifier tells how many occurrences of a given atom there can be. A quantifier refers to the element to the left of the quantifier. If there is no quantifier next to an atom, it means that the atom will have one occurrence (in the examples below, atom `b` always has one occurrence.\\r\\n\\r\\n- `*` - zero or more occurrences\\r\\n\\r\\n  e.g. `a*b` can translate into, among others, the following expressions: `b`, `ab`, `aab`, `aaaaaaab`, \u2026\\r\\n\\r\\n- `+` - one or more occurrences\\r\\n\\r\\n  e.g. `a+b` can translate into, among others, the following expressions: `ab`, `aab`, `aaaaab`, \u2026\\r\\n\\r\\n- `?` - zero or one occurrence\\r\\n\\r\\n  e.g. `a?b` translates to `b`, `ab`\\r\\n\\r\\n- `{min,max}` - At least `min` occurrences and maximum `max` occurrences\\r\\n\\r\\n  e.g. `a{2,4}b` translates into the expressions: `aab`, `aaab`, `aaaab`\\r\\n\\r\\n- `{min,}` - At least `min` occurrences. The maximum can be infinite.\\r\\n- `{,max}` - There is no minimum number of occurrences, and the maximum can be `max` occurrences\\r\\n- `{n}` - the exact number of occurrences equal to `n`\\r\\n\\r\\n  e.g. `a{4}b` - translates into: `aaaab`\\r\\n\\r\\n\\r\\n# Ranges []\\r\\n\\r\\nRange means that the expression can be one letter/number from a range. The dash `-` denotes a range from, to.\\r\\n\\r\\n- `[abc]` - means that the expression will be `a` or `b` or `c` (only one letter)\\r\\n- `[a-bB-Z]` - the expression can be `a`, `b`, `B`, `C`, `D`, \u2026, `Z`\\r\\n- `[a-Z]` - the expression can be any English character (uppercase or lowercase)\\r\\n- `[0-9]` - the expression can be any digit\\r\\n- `[a-Z\u0105\u0107\u0119\u0142\u0144\xf3\u015b\u017a\u017c\u0104\u0118\u0141\u0143\xd3\u015a\u0179\u017b]` - range of all Polish characters.\\r\\n\\r\\n# Groups ()\\r\\n\\r\\n- `(ab){2}` - means the expression `abab`\\r\\n\\r\\n#Flags\\r\\n\\r\\n- `(?i)` - ignore the case of letters to the right of this character\\r\\n\\r\\n# Special signs\\r\\n\\r\\n- `.` - any character\\r\\n- `$` - end of line (if we use this character at the end, it means that there is no character after the searched expression.\\r\\n- `^` - beginning of the line (if we use this character at the beginning, it means that there is no character before the searched expression.\\r\\n- `[^e]` - negation - the expression will not contain the letter `e`.\\r\\n- `|` - the sign means logical or, i.e. the expression will be any expression separated by the `|` sign\\r\\n\\r\\n  e.g. `a|b` - means `a` or `b`\\r\\n\\r\\n- `\\\\s` - Space, tab or newline\\r\\n- `\\\\S` - A character that is the negation of `\\\\s`, i.e. a character that is not a space, tab or newline character\\r\\n- `\\\\w` - letter, digit or character `_` (equivalent to `[a-Z_]`\\r\\n- `\\\\W` - a character that is the negation of `\\\\w`, i.e. a character that is not a letter, digit or `_`\\r\\n- `\\\\d` - digit (equivalent to `[0-9]`)\\r\\n- `\\\\D` - a character that is the negation of `\\\\d`, i.e. a character that is not a digit\\r\\n- `\\\\b` - Any whitespace character, the beginning of a string, the end of a string, and any character that is neither a letter nor a digit.\\r\\n\\r\\n**If we want to use one of the special characters in the regular expression such as `.`, `*`, `/`, `?`, `:`, `.`, `^`, `+`, `\\\\`, `=`, `|`, then we precede it with the `\\\\` character, e.g. `\\\\.`**"},{"id":"string-in-jvm-memory","metadata":{"permalink":"/blog/string-in-jvm-memory","source":"@site/blog/2024-05-16-String-memory-usage-jvm.md","title":"Calculating the memory usage by a String in JVM - JOL Footprint","description":"In short:","date":"2024-05-16T00:00:00.000Z","formattedDate":"May 16, 2024","tags":[{"label":"jvm","permalink":"/blog/tags/jvm"},{"label":"jol","permalink":"/blog/tags/jol"},{"label":"string","permalink":"/blog/tags/string"},{"label":"memory","permalink":"/blog/tags/memory"}],"readingTime":6.615,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"string-in-jvm-memory","title":"Calculating the memory usage by a String in JVM - JOL Footprint","authors":"bjab","tags":["jvm","jol","string","memory"]},"prevItem":{"title":"Regular expressions","permalink":"/blog/regular-expressions"},"nextItem":{"title":"Free YouTube Playlist Downloader to mp3 or mp4 - No Ads, No Hassle","permalink":"/blog/python-youtube-downloader"}},"content":"## In short:\\r\\n\\r\\n- The memory of the String object consists of 24 bytes for metadata + the number of characters times 1 byte or 2 bytes depending on the coder value\\r\\n  - Metadata: mark word x2 (4 bytes x2 = 8 bytes), class word (4 bytes), array reference byte[] or char[] (4 byte), hash (4 byte), hashIsZero (1 byte), coder (1 byte), padding (2 byte)\\r\\n- The String object has 2 additional flags:\\r\\n  - when `coder =1` then UTF-16 encoding (2 bytes per character)\\r\\n  - when `coder = 0` then LATIN-1 encoding (1 byte per character)\\r\\n  - hashIsZero is a flag that tells whether the hash calculation has already been performed\\r\\n\x3c!-- truncate --\x3e\\r\\n\\r\\n## JOL - String\\r\\n\\r\\nSince Java 9 we use Compact String, i.e. if possible, we use LATIN-1 encoding, and if not, coder=1 is set and we use UTF-16.\\r\\n\\r\\n(Before Java 9, everything was char[] and each letter was equal to 2 byte Utf-16.)\\r\\n\\r\\nIf at least one character is other than latin-1 (1 byte), each character in the String is encoded in utf16 (2 byte).\\r\\n\\r\\n```java\\r\\nString utf16String = \\"Bartosz Jab\u0142o\u0144ski\\"; // 17 znak\xf3w x 2 bytes = 34 bytes\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String).toPrintable());\\r\\nSystem.out.println(GraphLayout.parseInstance(utf16String).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String.getBytes()).toPrintable());\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());\\r\\n       \\r\\nString latin1String = \\"Bartosz Jablonski\\"; // 17 znak\xf3w x 1 bytes = 17 bytes\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String).toPrintable());\\r\\nSystem.out.println(GraphLayout.parseInstance(latin1String).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String.toCharArray()).toPrintable());\\r\\n```\\r\\n\\r\\n```\\r\\n#### Bartosz Jab\u0142o\u0144ski - UTF-16 - coder:1\\r\\njava.lang.String object internals:\\r\\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\\r\\n     12     4       int String.hash                               0\\r\\n     16     1      byte String.coder                              1\\r\\n     17     1   boolean String.hashIsZero                         false\\r\\n     18     2           (alignment/padding gap)                  \\r\\n     20     4    byte[] String.value                              [66, 0, 97, 0, 114, 0, 116, 0, 111, 0, 115, 0, 122, 0, 32, 0, 74, 0, 97, 0, 98, 0, 66, 1, 111, 0, 68, 1, 115, 0, 107, 0, 105, 0]\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\\r\\n\\r\\njava.lang.String@7dc222aed footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        56        56   [B\\r\\n         1        24        24   java.lang.String\\r\\n         2                  80   (total)\\r\\n\\r\\n[B object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\\r\\n     12     4        (object header)                           13 00 00 00 (00010011 00000000 00000000 00000000) (19)\\r\\n     16    19   byte [B.<elements>                             N/A\\r\\n     35     5        (loss due to the next object alignment)\\r\\nInstance size: 40 bytes\\r\\nSpace losses: 0 bytes internal + 5 bytes external = 5 bytes total\\r\\n\\r\\n[C object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    34   char [C.<elements>                             N/A\\r\\n     50     6        (loss due to the next object alignment)\\r\\nInstance size: 56 bytes\\r\\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\\r\\n```\\r\\n\\r\\nIn the first case, for `Bartosz Jab\u0142o\u0144ski`, where we included Polish characters not included in LATIN-1, you can see that the String has the `coder` flag set to `1`, i.e. it uses the `UTF-16` encoding type (2 bytes per character).\\r\\n\\r\\nThe footprint shows the deep size of the String object (17 characters) is 80 bytes. It consists of String and its metadata and the String object, i.e. the char[] array in UTF-16 encoding (2 byte per character).\\r\\nTo sum up:\\r\\n\\r\\n- 24 bytes - String with a reference takes 24 bytes (12 bytes for metadata (headers) + 4 bytes for hash(int) + 1 byte for coder, + 1 byte for hashIsZero + 4 bytes of references to the char array + 2 bytes for alligment padding ).\\r\\n  - Where the coder is responsible for: This value is closely related to the JVM implementation (hotspot). This is the encoding identifier used to encode bytes. Supported values are LATIN1 (coder=0) and UTF16(coder=1).\\r\\n         If at least one letter **is not included in LATIN1**, then coder=1 and the entire String will be encoded to UTF-16, i.e. it will take up (n letters * 2 bytes) in memory.\\r\\n        \\r\\n     - Where hashIsZero is responsible for: This field tells the JVM whether it can bypass hash recalculation. (this kind of cache)\\r\\n\\r\\n- 56 bytes - The byte[] array occupies 56 bytes, which consists of: 12 bytes of metadata (headers) + 4 bytes of metadata about the array (length) + data 17 characters * 2 bytes (34 bytes) = 50 bytes + 6 bytes for alignment . This is non-intuitively illustrated by the line of code: `System.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());`\\r\\n```java\\r\\n#### Bartosz Jablonski - LATIN-1 - coder:0\\r\\njava.lang.String object internals:\\r\\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\\r\\n     12     4       int String.hash                               0\\r\\n     16     1      byte String.coder                              0\\r\\n     17     1   boolean String.hashIsZero                         false\\r\\n     18     2           (alignment/padding gap)                  \\r\\n     20     4    byte[] String.value                              [66, 97, 114, 116, 111, 115, 122, 32, 74, 97, 98, 108, 111, 110, 115, 107, 105]\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\\r\\n\\r\\njava.lang.String@48a242ced footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        40        40   [B\\r\\n         1        24        24   java.lang.String\\r\\n         2                  64   (total)\\r\\n\\r\\n[B object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    17   byte [B.<elements>                             N/A\\r\\n     33     7        (loss due to the next object alignment)\\r\\nInstance size: 40 bytes\\r\\nSpace losses: 0 bytes internal + 7 bytes external = 7 bytes total\\r\\n\\r\\n[C object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    34   char [C.<elements>                             N/A\\r\\n     50     6        (loss due to the next object alignment)\\r\\nInstance size: 56 bytes\\r\\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\\r\\n```\\r\\n\\r\\nIn the second case for `Bartosz Jablonski`, where we did not include Polish characters, you can see that String has the coder flag set to 0, i.e. it uses LATIN-1 encoding (1 byte per character).\\r\\n\\r\\nThe footprint shows the deep size of the String object (17 characters) is 64 bytes. It consists of String and its metadata and the String object, i.e. the byte[] array in LATIN-1 encoding (1 byte per character).\\r\\n\\r\\n- String with a reference takes 24 bytes (12 bytes for metadata (headers) + 4 bytes for hash(int) + 1 byte for coder + 1 byte for hashIsZero + 4 bytes for references to the array of entities + 2 bytes for alligment padding).\\r\\n- The byte[] array takes 40 bytes, which consists of: 12 bytes of metadata (headers) + 4 bytes of metadata about the array (length) + 17 character data * 1 byte (17 bytes) = 33 bytes + 7 bytes for alignment.\\r\\n\\r\\nThis is illustrated by the line of code: `System.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());`\\r\\n\\r\\nThanks to the `coder` flag and the lack of special characters, we have a gain of 16 bytes in less memory consumption - which happens without our programming intervention."},{"id":"python-youtube-downloader","metadata":{"permalink":"/blog/python-youtube-downloader","source":"@site/blog/2024-05-16-youtube-downloader.md","title":"Free YouTube Playlist Downloader to mp3 or mp4 - No Ads, No Hassle","description":"I recently stopped using Spotify Premium and it has become more difficult to listen to music and podcasts on the plane. So far, I have downloaded mp3 and mp4 using online tools such as:","date":"2024-05-16T00:00:00.000Z","formattedDate":"May 16, 2024","tags":[{"label":"python","permalink":"/blog/tags/python"},{"label":"scripts","permalink":"/blog/tags/scripts"},{"label":"tools","permalink":"/blog/tags/tools"}],"readingTime":3.435,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"python-youtube-downloader","title":"Free YouTube Playlist Downloader to mp3 or mp4 - No Ads, No Hassle","authors":"bjab","tags":["python","scripts","tools"]},"prevItem":{"title":"Calculating the memory usage by a String in JVM - JOL Footprint","permalink":"/blog/string-in-jvm-memory"}},"content":"I recently stopped using Spotify Premium and it has become more difficult to listen to music and podcasts on the plane. So far, I have downloaded mp3 and mp4 using online tools such as:\\r\\n\\r\\n- https://notube.net/pl/youtube-app-v103\\r\\n- https://y2down.cc/pl/youtube-mp4.html and others\\r\\n\\r\\nUnfortunately, tools of this type allow you to download individual videos and bombard us with a lot of invasive advertisements. To avoid these problems, we will write a script in Python which, after providing a link to a playlist or movie, will download an mp3 or mp4.\\r\\n\\r\\nWe will use the library [pytube](https://pytube.io/en/latest/) to write the script .\\r\\n\\r\\nYou can find the entire script in the repository gitlab: https://gitlab.com/bart_as93/youtube-downloader\\r\\n\x3c!-- truncate --\x3e\\r\\n### 1. Initial setup\\r\\n\\r\\nClone the repository to your local machine:\\r\\n\\r\\n```bash\\r\\ngit clone https://gitlab.com/bart_as93/youtube-downloader.git\\r\\ncd youtube-downloader\\r\\n```\\r\\n\\r\\nCheck python versions\\r\\n\\r\\n```bash\\r\\npython --version\\r\\n```\\r\\n\\r\\nIn my case `Python 3.11.4`\\r\\n\\r\\nThen we install the dependencies\\r\\n\\r\\n```bash\\r\\npip install -r requirements.txt\\r\\n```\\r\\n\\r\\nThen we run the script, e.g.:\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -u https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d music -f mp4\\r\\n```\\r\\n\\r\\nThe script takes 4 arguments:\\r\\n\\r\\n- `-f` - format one of: mp3 or mp4\\r\\n- `-d` - directory where to download files\\r\\n- and one of below:\\r\\n    - `-u` - Url to youtube video\\r\\n    - `-pu` - Url to playlist\\r\\n\\r\\n### YouTube to mp4\\r\\n\\r\\nTo download a YouTube video you need to use the `-u <link_to_video>` flag and `f mp4` flag\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -u https://www.youtube.com/watch?v=a59gmGkq_pw -d movies -f mp4\\r\\n```\\r\\n\\r\\n### YouTube to mp3\\r\\n\\r\\nTo download audio from YouTube video you need to use the `-u <link_to_video>` flag and `-f mp3` flag.\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -u https://www.youtube.com/watch?v=a59gmGkq_pw -d music -f mp3\\r\\n```\\r\\n\\r\\n### YouTube Playlist to mp4\\r\\n\\r\\nTo download videos from YouTube playlist you need to use `-pu <link_to_playlist>` flag and `-f mp4` flag.\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -pu https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d music-f mp4\\r\\n```\\r\\n\\r\\n### YouTube Playlist to mp3\\r\\n\\r\\nTo download audio from YouTube playlist you need to use `-pu <link_to_playlist>` flag and `-f mp3` flag.\\r\\n\\r\\n```bash\\r\\npython .\\\\[downloader.py](http://downloader.py/) -pu https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d movies -f mp3\\r\\n```\\r\\n\\r\\n## Code overview (comments in code):\\r\\n\\r\\n```python\\r\\nimport argparse\\r\\nimport os\\r\\nfrom pytube import Playlist\\r\\nfrom pytube import YouTube\\r\\n\\r\\n# The program supports two formats: mp3 and mp4. In the else section, if the format is different, the program is disabled\\r\\ndef downloadByVideo(vid):\\r\\n    print(\'downloading : {} - {} with url : {}\'.format(video.author, video.title, video.watch_url))\\r\\n    global type\\r\\n    vidFileName = vid.author + \\" - \\" + vid.title + \\".\\" + format\\r\\n    if format == \'mp3\':\\r\\n        type = \'audio\'\\r\\n# On the video object, we refer to streams, filter only audio and call the download method with options describing the target directory in which the file will be saved and the file name\\r\\n        vid.streams. \\\\\\r\\n            filter(only_audio=True).desc().first(). \\\\\\r\\n            download(output_path=DOWNLOAD_DIR, filename=vidFileName)\\r\\n    elif format == \'mp4\':\\r\\n        type = \'video\'\\r\\n# On the video object, we refer to streams, filter only the video, sort from the highest resolution and call the download method with options describing the target directory in which the file will be saved and the file name\\r\\n        vid.streams. \\\\\\r\\n            filter(type=type, progressive=True, file_extension=format). \\\\\\r\\n            order_by(\'resolution\'). \\\\\\r\\n            desc(). \\\\\\r\\n            first(). \\\\\\r\\n            download(output_path=DOWNLOAD_DIR, filename=vidFileName)\\r\\n    else:\\r\\n        print(f\\"Not supported format type: {format}\\")\\r\\n        exit()\\r\\n\\r\\n# Handling command line parameters and checking required fields\\r\\nparser = argparse.ArgumentParser()\\r\\n\\r\\nparser.add_argument(\\"-u\\", \\"--Url\\", help=\\"Youtube video url\\")\\r\\nparser.add_argument(\\"-pu\\", \\"--PlayListUrl\\", help=\\"Playlist url\\")\\r\\nparser.add_argument(\\"-f\\", \\"--Format\\", help=\\"Format of downloaded files - mp3 or mp4\\")\\r\\nparser.add_argument(\\"-d\\", \\"--Destination\\", help=\\"Destination folder of downloaded files\\")\\r\\n\\r\\nformat=\\"mp3\\"\\r\\n\\r\\nargs = parser.parse_args()\\r\\n\\r\\nif not args.Url and not args.PlayListUrl:\\r\\n    print(\\"Please provide youtube playlist url via -pu or --PlayListUrl argument param or Youtube video url via -u or --Url\\")\\r\\n    exit()\\r\\nif not args.Destination:\\r\\n    print(\\"Please provide destination folder name via -d or --Destination argument param\\")\\r\\n    exit()\\r\\nif not args.Format:\\r\\n    print(\\"Format (-f or --Format not provided - default set to mp3\\")\\r\\nelse:\\r\\n    format=args.Format\\r\\n\\r\\nDOWNLOAD_DIR = os.getcwd() + \\"\\\\\\\\out\\\\\\\\\\" + args.Destination\\r\\n\\r\\n# We check whether the URL to the Playlist (-pu) or the URL to the movie (-u) has been entered and the movie or playlist is downloaded based on the URL\\r\\nif(args.PlayListUrl):\\r\\n    playlist = Playlist(args.PlayListUrl)\\r\\n    print (f\\"Downloading {len(playlist.videos)} files from playlist with url: {args.Url}, with format: {args.Format}, to dir: {DOWNLOAD_DIR}\\")\\r\\n\\r\\n    for video in playlist.videos:\\r\\n        downloadByVideo(video)\\r\\n\\r\\nif (args.Url):\\r\\n    video = YouTube(args.Url)\\r\\n    downloadByVideo(video)\\r\\n```"}]}')}}]);