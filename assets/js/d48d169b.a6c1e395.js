"use strict";(self.webpackChunklearning_notes=self.webpackChunklearning_notes||[]).push([[6671],{63063:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var s=n(85893),r=n(11151);const i={title:"Taobao HangZhou Interview Round 1",authors:"xiaohai",tags:["study","interview"]},o=void 0,a={permalink:"/blog/2024/02/28/taobao-interview-round-1",editUrl:"https://github.com/xiaohai-huang/learning-notes/tree/master/blog/2024/02-28-taobao-interview-round-1/index.mdx",source:"@site/blog/2024/02-28-taobao-interview-round-1/index.mdx",title:"Taobao HangZhou Interview Round 1",description:"1.  How do you decide when to run useLayoutEffect?",date:"2024-02-28T00:00:00.000Z",formattedDate:"28 February 2024",tags:[{label:"study",permalink:"/blog/tags/study"},{label:"interview",permalink:"/blog/tags/interview"}],readingTime:2.585,hasTruncateMarker:!0,authors:[{name:"Xiaohai Huang",title:"CS Student",url:"http://github.com/xiaohai-huang",imageURL:"https://github.com/xiaohai-huang.png",key:"xiaohai"}],frontMatter:{title:"Taobao HangZhou Interview Round 1",authors:"xiaohai",tags:["study","interview"]},unlisted:!1,nextItem:{title:"Perform In-Game Updates in Unity using HybridCLR and Addressables",permalink:"/blog/2023/03/25/unity-hot-update"}},d={authorsImageUrls:[void 0]},c=[];function l(e){const t=Object.assign({ol:"ol",li:"li",p:"p",code:"code",strong:"strong",ul:"ul",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,r.ah)(),e.components);return(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["How do you decide when to run ",(0,s.jsx)(t.code,{children:"useLayoutEffect"}),"?"]}),"\n",(0,s.jsxs)(t.p,{children:["Ans: ",(0,s.jsx)(t.code,{children:"useLayoutEffect"})," is a version of ",(0,s.jsx)(t.code,{children:"useEffect"})," that fires before the browser ",(0,s.jsx)(t.strong,{children:"repaints"})," the screen."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Measuring layout before the browser repaints the screen."}),"\n",(0,s.jsx)(t.li,{children:"Blocks the browser from repainting."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The execution order of ",(0,s.jsx)(t.code,{children:"useEffect"})," and ",(0,s.jsx)(t.code,{children:"useLayoutEffect"}),"."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Feature"}),(0,s.jsx)(t.th,{children:"useEffect"}),(0,s.jsx)(t.th,{children:"useLayoutEffect"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Execution Timing"}),(0,s.jsx)(t.td,{children:"Runs after the render is committed to the screen. This means it runs after the browser has painted changes to the screen."}),(0,s.jsx)(t.td,{children:"Runs synchronously after all DOM mutations. This means it runs before the browser has a chance to paint, making it suitable for reading layout from the DOM and synchronously re-rendering."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Use Cases"}),(0,s.jsx)(t.td,{children:"Most side effects (data fetching, subscriptions)"}),(0,s.jsx)(t.td,{children:"DOM manipulation, measuring elements, critical layout updates"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Performance"}),(0,s.jsx)(t.td,{children:"Generally better performance due to async nature"}),(0,s.jsx)(t.td,{children:"Can impact performance if used excessively, as it blocks the browser from repainting"})]})]})]}),"\n"]}),"\n"]})}const h=function(e={}){const{wrapper:t}=Object.assign({},(0,r.ah)(),e.components);return t?(0,s.jsx)(t,Object.assign({},e,{children:(0,s.jsx)(l,e)})):l(e)}},11151:(e,t,n)=>{n.d(t,{Zo:()=>a,ah:()=>i});var s=n(67294);const r=s.createContext({});function i(e){const t=s.useContext(r);return s.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const o={};function a({components:e,children:t,disableParentContext:n}){let a;return a=n?"function"==typeof e?e({}):e||o:i(e),s.createElement(r.Provider,{value:a},t)}}}]);