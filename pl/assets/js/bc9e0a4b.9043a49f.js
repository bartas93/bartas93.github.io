"use strict";(self.webpackChunkbj_blog=self.webpackChunkbj_blog||[]).push([[1307],{4733:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"jvm-memory-allocation-of-objects","metadata":{"permalink":"/pl/blog/jvm-memory-allocation-of-objects","source":"@site/i18n/pl/docusaurus-plugin-content-blog/2024-05-16-jvm-memory-allocation-of-objects.md","title":"Sprawdzenie dok\u0142adnej alokacji pami\u0119ci JVM - biblioteka jol (Java Object Layout)","description":"W skr\xf3cie","date":"2024-05-16T00:00:00.000Z","formattedDate":"16 maja 2024","tags":[{"label":"jvm","permalink":"/pl/blog/tags/jvm"},{"label":"jol","permalink":"/pl/blog/tags/jol"},{"label":"heap","permalink":"/pl/blog/tags/heap"},{"label":"memory","permalink":"/pl/blog/tags/memory"},{"label":"references","permalink":"/pl/blog/tags/references"}],"readingTime":13.175,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"jvm-memory-allocation-of-objects","title":"Sprawdzenie dok\u0142adnej alokacji pami\u0119ci JVM - biblioteka jol (Java Object Layout)","authors":"bjab","tags":["jvm","jol","heap","memory","references"]},"nextItem":{"title":"Wyra\u017cenia regularne","permalink":"/pl/blog/regular-expressions"}},"content":"## W skr\xf3cie\\r\\n\\r\\n- Ka\u017cdy obiekt ma narzut pami\u0119ci (metadane) (12-16 bajt\xf3w na metadane - referencja, headery + pami\u0119\u0107 na dane).\\r\\n- Procesory (CPU) mog\u0105 by\u0107 32 bitowe (4 byte - maxymalnie 4 GB pami\u0119ci RAM) lub 64 bitowe (8 byte). To oznacza tyle, \u017ce CPU ma dost\u0119p do ty\u0142u adres\xf3w ile mo\u017cna zapisa\u0107 w 4 lub 8 bytach. Dodatkowo CPU pobiera paczkami dane z RAM po 8 byt\xf3w naraz.\\r\\n- Padding - wyr\xf3wnanie do 8 bajt\xf3w - czyli obiekty zajmuj\u0105 pami\u0119\u0107 r\xf3wn\u0105 wielokrotno\u015bci 8 bajt\xf3w. Mo\u017cna to zwi\u0119kszy\u0107 bo ogranicza to u\u017cycie maksymalnego heapa na poziomie 32 GB.\\r\\n- Referencja zajmuje 4 (32bit CPU lub 64bit CPU z Compressed References (default)) lub 8 bajt\xf3w (64bit CPU).\\r\\n  - Maksymalny heap dla Compressed References = 32 GB - wykorzystanie przesuni\u0119cia bitowego o 3 miejsca ze wzgl\u0119du na to \u017ce zapis 8 byte zawsze po prawej stronie ma trzy zera. (8 byte bo jest wyr\xf3wnanie do 8 byt\xf3w). Dlatego mo\u017cemy u\u017cy\u0107 32 GB heapa zamiast 4 GB.\\r\\n  - Gdy u\u017cywamy 64bit CPU z Compressed References i zwi\u0119kszymy Pami\u0119\u0107 heapa powy\u017cej 32 GB mo\u017cemy mie\u0107 problemy z aplikacj\u0105 i znacz\u0105cy wzrost zajmowanego heapa ze wzgl\u0119du na zmian\u0119 pami\u0119ci referencji z 4 bytes do 8 bytes - np. zmiana z -Xmx31g do -Xmx33g mo\u017ce spowodowa\u0107 wzrost zaj\u0119cia danych o 40% (w zale\u017cno\u015bci od danych)\\r\\n\x3c!-- truncate --\x3e\\r\\n## Konfiguracja\\r\\n\\r\\nAby sprawdzi\u0107 jak wygl\u0105da uk\u0142ad pami\u0119ci (memory layout) u\u017cyjemy biblioteki:\\r\\n\\r\\n```xml\\r\\n<dependency>\\r\\n    <groupId>org.openjdk.jol</groupId>\\r\\n    <artifactId>jol-core</artifactId>\\r\\n    <version>0.10</version>\\r\\n</dependency>\\r\\n```\\r\\n\\r\\nJol to taki toolbox do analizowania uk\u0142adu obiekt\xf3w w JVM. Te narz\u0119dzia u\u017cywaj\u0105 (w celu dekodowania rzeczywistego uk\u0142adu obiektu (object layout), jego zajmowanej pami\u0119ci (footprint) i referencji (references)). Jol u\u017cywa takich narz\u0119dzi jak:\\r\\n\\r\\n- Unsafe\\r\\n- JVMTI\\r\\n- Serviceability Agent (SA)\\r\\n\\r\\n## Dost\u0119pne metody\\r\\n\\r\\n### Detale VM - `VM.current().details()` - Podstawowe dane zwi\u0105zane z nasz\u0105 JVM\\r\\n\\r\\n```\\r\\n# Running 64-bit HotSpot VM.\\r\\n# Using compressed oop with 3-bit shift.\\r\\n# Using compressed klass with 3-bit shift.\\r\\n# WARNING | Compressed references base/shifts are guessed by the experiment!\\r\\n# WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\\r\\n# WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\\r\\n# Objects are 8 bytes aligned.\\r\\n# Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\\r\\n# Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\\r\\n```\\r\\n\\r\\n1. Uruchamiamy nasz program na **64** bitowej wersji **JVM \u2013 HotSpot**\\r\\n2. `Using compressed oop with 3-bit shift.` - [wi\u0119cej](#compressed-vs-uncompressed-references)\\r\\n3. `Using compressed klass with 3-bit shift.` - [wi\u0119cej](#compressed-vs-uncompressed-references)\\r\\n4. `Objects are 8 bytes aligned.` - Obiekty b\u0119d\u0105 wyr\xf3wnane do **8** bajt\xf3w - oznacza to tyle, \u017ce ka\u017cdy obiekt nawet jak powinien zajmowa\u0107 20 byt\xf3w to i tak zajmuje wielokrotno\u015b\u0107 8 bajt\xf3w czyli w tym przypadku 24 bajty. Zawsze idzie w g\xf3r\u0119 do wielokrotno\u015bci 8 bajt\xf3w.\\r\\n  1. Dlaczego?\\r\\n     Procesory s\u0105 32 lub 64 bitowe (32 bit CPU mo\u017ce u\u017cy\u0107 max 4 GB pami\u0119ci). Czyli 4 lub 8 bytowe. Co oznacza, \u017ce odczytuj\u0105 (z rejestru pami\u0119ci poprzez zewn\u0119trzn\u0105 magistral\u0119) po 4 lub 8 byt\xf3w pami\u0119ci naraz. CPU nie pobiera pojedynczych bit\xf3w lub byt\xf3w. Pobiera paczkami. Jest to spowodowane tym \u017ce CPU (np. 3GHz) jest szybsze ni\u017c pami\u0119\u0107 (400MHz). Wykorzystuj\u0105c to \u017ce CPU jest szybsze pobieramy paczkami dane. Aby u\u0142atwi\u0107 (i przyspieszy\u0107) to wyci\u0105ganie danych, JVM grupuje te dane po 8 byt\xf3w dla 64 bitowej maszyny (czyli wi\u0119kszo\u015b\u0107 wsp\xf3\u0142czesnych).\\r\\n\\r\\n  1. Mo\u017cna to zmieni\u0107 flag\u0105 JVM: `*-XX:ObjectAlignmentInBytes=16` (Dost\u0119pne warto\u015bci 8,16,32,64,128,256, inaczej JVM rzuci b\u0142\u0105d i nie uruchomi aplikacji). Flaga, przez kt\xf3r\u0105 wi\u0119kszo\u015b\u0107 obiekt\xf3w b\u0119dzie zajmowa\u0142o du\u017co wi\u0119cej nieu\u017cytej pami\u0119ci. Zal\u0119t\u0105 tego rozwi\u0105zania jest \u017ce mo\u017cemy wtedy u\u017cy\u0107 64 GB Heap z skompresowanymi referencjami. (Poniewa\u017c 3 bit shifting zmieni si\u0119 na 4 bit shifting - 16 byte zawsze ma 4 zera po prawej stronie)*\\r\\n5. Nast\u0119pnie s\u0105 pokazane rozmiary typ\xf3w w naszej JVM\\r\\n  1. Referencja obiektu: 4 bytes - w tym przypadku jest w\u0142\u0105czona domy\u015blnie flaga Compressed References - dlatego w 64 bitowej JVM referencja zajmuje 4 bytes a nie tak jak powinien 8 bytes. Aby zajmowa\u0142o 8 bytes to nalezy uruchomi\u0107 JVM z flag\u0105: *`-XX:-UseCompressedOops`*\\r\\n\\r\\n     Dodatkowo nale\u017cy pami\u0119ta\u0107 \u017ce 4 bytes to 32 bit\xf3w czyli 2^32 mo\u017cliwych unikalnych adres\xf3w referencji do zapisania (przy compressed oops wykorzystywane jest przesuni\u0119cie o e bity co efektywnie daje nam a\u017c 8 razy wi\u0119cej mo\u017cliwych adres\xf3w)\\r\\n\\r\\n  2. boolean i byte: 1 byte\\r\\n  3. short and char: 2bytes\\r\\n  4. int and float: 4 bytes\\r\\n  5. long and double 8 bytes\\r\\n\\r\\n## Typy okre\u015ble\u0144 zajmowanej pami\u0119ci:\\r\\n\\r\\n- Shallow size - to co nam ClassLayout m\xf3wi\\r\\n- Deep size - to co nam footprint m\xf3wi\\r\\n- Retained size - to co zwalnia GC - np. te wielko\u015bci pokazywane s\u0105 w heapdump\\r\\n\\r\\n![Typy plik\xf3w](/blog/size-types.png)\\r\\n\\r\\nNa powy\u017cszym przyk\u0142adzie - Retained size to zwolniona pami\u0119\u0107 po usuni\u0119ciu referencji Triple - tylko Ai + Ci jest zwalniane a Bi jest u\u017cywane przez Pair. Te dodatkowe referencje komplikuj\u0105 retained size. Retained size jest zawsze pomi\u0119dzy shallow a deep size.\\r\\n\\r\\n### Uk\u0142ad klasy - ClassLayout (shallow size)\\r\\n\\r\\n`ClassLayout.parseClass(Basket.class).toPrintable(b1))`\\r\\n\\r\\nWszystkie obiekty przechowuj\u0105 dane typu podstawowego. Maj\u0105 sw\xf3j dodatkowy narzut pami\u0119ci (metadane). Uk\u0142ad klasy pokazuje nam ile bajt\xf3w zajmuj\u0105 headery, ile zajmuj\u0105 pola typu prostego danej klasy, ile zajmuj\u0105 referencje do innych pod obiekt\xf3w (ale nie pokazuje ile pod obiekt zajmuje pami\u0119ci). Dodatkowo pokazuje przesuni\u0119cie (np. 4 bytes external) - czyli przesuni\u0119cie do 8 bajt\xf3w\\r\\n\\r\\n```java\\r\\n@Data\\r\\n@AllArgsConstructor\\r\\npublic class ExampleClass {\\r\\n    private int a;\\r\\n    private int b;\\r\\n}\\r\\n...\\r\\nExampleClass b1 = new ExampleClass(1232132, 123);\\r\\nSystem.out.println(ClassLayout.parseClass(ExampleClass.class).toPrintable(b1));\\r\\n```\\r\\n\\r\\n```\\r\\ncom.example.demo.ExampleClass object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 ed d3 b0 (00000001 11101101 11010011 10110000) (-1328288511)\\r\\n      4     4        (object header)                           6f 00 00 00 (01101111 00000000 00000000 00000000) (111)\\r\\n      8     4        (object header)                           78 f2 01 01 (01111000 11110010 00000001 00000001) (16904824)\\r\\n     12     4    int ExampleClass.a                            1232132\\r\\n     16     4    int ExampleClass.b                            123\\r\\n     20     4        (loss due to the next object alignment)\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\\r\\n```\\r\\n\\r\\n### **Metadane:**\\r\\n\\r\\n- headery:\\r\\n  - flagi (0\u21924 bajt\xf3w) (mark word)- przechowuj\u0105 informacje o stanie obiektu. Mi\u0119dzy innymi shape obiektu, czyli czy jest to klasa czy tablica oraz hash code oraz ilo\u015b\u0107 przetrwa\u0144 GC do promocji do OldGeneration- 4 bajty\\r\\n  - lock (4\u21928 bajt\xf3w) (mark word) - monitor, kt\xf3ry b\u0119dzie wykorzystywany do mutex\xf3w - 4 bajty\\r\\n\\r\\n      ```java\\r\\n      public class Lock {}\\r\\n      ...\\r\\n      Lock lock = new Lock();\\r\\n      /*\\r\\n      Lock object internals:\\r\\n       OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n            0     4        (object header)                           01 00 00 00 \\r\\n            4     4        (object header)                           00 **00** 00 00\\r\\n            8     4        (object header)                           85 23 02 f8\\r\\n           12     4        (loss due to the next object alignment)\\r\\n      Instance size: 16 bytes\\r\\n      */\\r\\n      synchronized (lock) {\\r\\n          System.out.println(ClassLayout.parseInstance(lock).toPrintable());\\r\\n      }\\r\\n      /*\\r\\n      Pierwszy header si\u0119 zmieni\u0142 poniewa\u017c przeliczony zosta\u0142 domy\u015blny hashCode()\\r\\n      Drugi header si\u0119 zmieni\u0142 ze wzgl\u0119du na lock!\\r\\n      Lock object internals:\\r\\n       OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n            0     4        (object header)                           f0 78 12 03\\r\\n            4     4        (object header)                           00 **70** 00 00\\r\\n            8     4        (object header)                           85 23 02 f8\\r\\n           12     4        (loss due to the next object alignment)\\r\\n      */\\r\\n      ```\\r\\n\\r\\n  - class (8\u219212 bajt\xf3w) (klass word)- wska\u017anik do typu w naszym przypadku 4 bajty\\r\\n  - size - rozmiar tablicy (warto\u015b\u0107 ta obecna jest tylko dla typ\xf3w tablicowych) - w przyk\u0142adzie powy\u017cej tego nie ma (4 byte)\\r\\n\\r\\n\\r\\n- Dane\\r\\n  - pola klasy - reszta bajt\xf3w w naszym przyk\u0142adzie 2x4 bajty na pola int.\\r\\n- + ewentualne przesuni\u0119cie do 8 bajt\xf3w (w naszym przypadku 4 bajty przesuni\u0119cia )\\r\\n\\r\\n### Footprint (Deep size)\\r\\n\\r\\nJe\u015bli mamy jakie\u015b odniesienia do innych obiekt\xf3w w naszym analizowanym obiekcie to ClassLayout poka\u017ce tylko dodatkowe 4 bajty na referencj\u0119 (Nie we\u017amie pod uwag\u0119 zawarto\u015bci obiektu do kt\xf3rego si\u0119 odnosimy) - w takim przypadku warto wykorzysta\u0107 FootPrint kt\xf3ry poka\u017ce ile zajmuje pami\u0119ci ca\u0142y obiekt razem z obiektem wewn\u0105trz.\\r\\n\\r\\n```java\\r\\n@Data\\r\\n@AllArgsConstructor\\r\\npublic class ExampleClass {\\r\\n    private int a;\\r\\n    private int b;\\r\\n    private int c;\\r\\n    private InnerClass d;\\r\\n\\r\\n    @Data\\r\\n    @AllArgsConstructor\\r\\n    public static class InnerClass {\\r\\n        private int a;\\r\\n        private int b;\\r\\n    }\\r\\n}\\r\\n...\\r\\nExampleClass.InnerClass inner = new ExampleClass.InnerClass(10, 12);\\r\\nExampleClass b1 = new ExampleClass(1232132, 123,111, inner);\\r\\n\\r\\nSystem.out.println(GraphLayout.parseInstance(b1).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseClass(ExampleClass.class).toPrintable(b1));\\r\\nSystem.out.println(ClassLayout.parseClass(ExampleClass.InnerClass.class).toPrintable(inner));\\r\\n```\\r\\n\\r\\n```java\\r\\n### FOOTPRINT\\r\\ncom.example.demo.ExampleClass@6dde5c8cd footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        32        32   com.example.demo.ExampleClass\\r\\n         1        24        24   com.example.demo.ExampleClass$InnerClass\\r\\n         2                  56   (total)\\r\\n\\r\\n### CLASSLAYOUT\\r\\ncom.example.demo.ExampleClass object internals:\\r\\n OFFSET  SIZE                                       TYPE DESCRIPTION                               VALUE\\r\\n      0     4                                            (object header)                           01 8c 5c de (00000001 10001100 01011100 11011110) (-564360191)\\r\\n      4     4                                            (object header)                           6d 00 00 00 (01101101 00000000 00000000 00000000) (109)\\r\\n      8     4                                            (object header)                           a0 f4 01 01 (10100000 11110100 00000001 00000001) (16905376)\\r\\n     12     4                                        int ExampleClass.a                            1232132\\r\\n     16     4                                        int ExampleClass.b                            123\\r\\n     20     4                                        int ExampleClass.c                            111\\r\\n     24     4   com.example.demo.ExampleClass.InnerClass ExampleClass.d                            (object)\\r\\n     28     4                                            (loss due to the next object alignment)\\r\\nInstance size: 32 bytes\\r\\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\\r\\n\\r\\ncom.example.demo.ExampleClass$InnerClass object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 5b 3e 5b (00000001 01011011 00111110 01011011) (1530813185)\\r\\n      4     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      8     4        (object header)                           78 f2 01 01 (01111000 11110010 00000001 00000001) (16904824)\\r\\n     12     4    int InnerClass.a                              10\\r\\n     16     4    int InnerClass.b                              12\\r\\n     20     4        (loss due to the next object alignment)\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\\r\\n```\\r\\n\\r\\nPowy\u017cej mamy por\xf3wnanie Footprint i ClassLayout. W Footprint widzimy dok\u0142adnie ile bajt\xf3w zajmuje obiekt z jego podobiektami (56 bajt\xf3w). A w ClassLayout widzimy tylko przegl\u0105d danej klasy bez pod obiekt\xf3w (32 bytes i 24 bytes).\\r\\n\\r\\nRozbijmy footprint aby jeszcze bardziej by\u0142o to zrozumia\u0142e:\\r\\n\\r\\nNa 56 bytes sk\u0142\u0105da si\u0119:\\r\\nExampleClass: 12 bajt\xf3w na metadane + 3x 4 bajty na inta + 4 bajty na referencje = 28 bajt\xf3w\\r\\n28 bajt\xf3w + 4bajt\xf3w (wyr\xf3wnanie do 8 bajt\xf3w) = **32 bajt\xf3w**\\r\\nInnerClass: 12 bajt\xf3w na metadane + 2x 4 bajty na inta = 20 bajt\xf3w - nie jest to wielokrotno\u015b\u0107 8 bajt\xf3w (wyr\xf3wnanie) wi\u0119c: 20 bajt\xf3w + 4 bajt\xf3w = 24 bajty.\\r\\n\\r\\n### Compressed vs Uncompressed References\\r\\n\\r\\nDzi\u0119ki temu \u017ce jest wyr\xf3wnanie do wielokrotno\u015bci 8 byte, mo\u017cemy wykorzysta\u0107 pewn\u0105 ciekaw\u0105 w\u0142asno\u015b\u0107 jak\u0105 jest zapis takich liczb w formie binarnej. Wszystkie wielokrotno\u015bci liczby 8 w formie binarnej ko\u0144cz\u0105 si\u0119 minimum trzema zerami (z prawej strony). Znaj\u0105c t\u0105 prawid\u0142owo\u015b\u0107 programi\u015bci JVM wykorzystali t\u0105 w\u0142asno\u015b\u0107 tak \u017ce robi\u0105 przesuni\u0119cie o 3 bity w prawo co powoduje \u017ce do zapisu adres\xf3w pami\u0119ci mamy dodatkowe 3 bity. Co zwi\u0119ksza nam zakres z 2^32~4GB do 2^(32+3)~32GB. (8 razy wi\u0119cej mo\u017cliwych adres\xf3w)\\r\\n\\r\\n**Dzi\u0119ki temu pozwalamy na wi\u0119cej ni\u017c 4 GB przestrzeni na stercie z referencjami 32-bitowymi na maszynach 64-bitowych!**\\r\\n\\r\\n![Bit shifting](/blog/bit-shifting.png)\\r\\n\\r\\nDomy\u015blnie uruchomiona jest kompresja referencji. To oznacza tyle, \u017ce klass word zajmuje 4 byt\xf3w oraz ka\u017cda referencja zajmuje 4 byt\xf3w. Takie ustawienia maj\u0105 limit **32 GB heapa.** Gdy u\u017cywamy wi\u0119cej ni\u017c 32 GB heapa to automatycznie kompresja jest wy\u0142\u0105czana. Ewentualnie mo\u017cemy r\u0119cznie wy\u0142\u0105czy\u0107 kompresje referencji poprzez *`-XX:-UseCompressedOops`- gdzie takie ustawienie wy\u0142\u0105cza kompresowanie referencji i wtedy rozmiar referencji wynosi 8 byt\xf3w.*\\r\\n\\r\\n### Powy\u017cej 32 GB\\r\\n\\r\\nJe\u015bli chcemy u\u017cy\u0107 wi\u0119cej ni\u017c 32 GB heapa i chcemy u\u017cywa\u0107 compressed reference:\\r\\n\\r\\nWz\xf3r na maxymalny heap size: 4GB * ObjectAlignmentInBytes. - ale nale\u017cy pami\u0119ta\u0107, \u017ce allignments wzrasta dla ka\u017cdego istniej\u0105cego obiektu co w konsekwencji zwi\u0119ksza rozmiar ka\u017cdego obiektu. Nie zawsze si\u0119 to op\u0142aci.\\r\\n\\r\\n### Co to jest padding/alligment gap (internal space losses)\\r\\n\\r\\nDope\u0142nienie bajt\xf3w do wielokrotno\u015bci 8 bajt\xf3w mo\u017ce przyj\u0105\u0107 2 formy\\r\\n\\r\\n- internal space losses\\r\\n- external space losses\\r\\n\\r\\nProcesor pobiera dane po 8 byt\xf3w naraz. Aby u\u0142atwi\u0107 pobieranie danych robimy przesuni\u0119cia. Przyk\u0142ad u\u0142atwienia pobierania danych z internal space losses - dla \u0142atwiejszego ukazania przyk\u0142adu wykorzystano flag\u0119 JVM *`-XX:ObjectAlignmentInBytes=16`*:\\r\\n\\r\\n```\\r\\nSimpleLong object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0    12        (object header)                           N/A\\r\\n     12     4        (alignment/padding gap)                  \\r\\n     16     8   long SimpleLong.state                          N/A\\r\\n     24     8        (loss due to the next object alignment)\\r\\nInstance size: 32 bytes\\r\\nSpace losses: 4 bytes internal + 8 bytes external = 12 bytes total\\r\\n```\\r\\n\\r\\nPo 12 bajtach zwi\u0105zanych z headerem dodany zosta\u0142 internal aligment/padding gap = 4 bajty. tak aby wyci\u0105ganie longa by\u0142o w jednym procesie CPU. (tak aby long variable by\u0142o w offsecie 16)\\r\\n\\r\\n### Field Packing - Upakowanie p\xf3l\\r\\n\\r\\nO kolejno\u015bci upakowania p\xf3l w pami\u0119ci decyduje JVM a nie deklaracja p\xf3l w implementacji klasy. Jest to po to aby w\u0142a\u015bnie u\u0142atwi\u0107 kondensowanie wielokrotno\u015bci 8 bajt\xf3w tak aby np. int nie by\u0142 rozdzielony na 2 wyci\u0105gni\u0119cia danych po 8 bajt\xf3w.\\r\\n\\r\\n```\\r\\npublic class FieldsArrangement {\\r\\n    private boolean first;\\r\\n    private char second;\\r\\n    private double third;\\r\\n    private int fourth;\\r\\n    private boolean fifth;\\r\\n}\\r\\n...\\r\\nOFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0    12           (object header)                           N/A\\r\\n     12     4       int FieldsArrangement.fourth                  N/A\\r\\n     16     8    double FieldsArrangement.third                   N/A\\r\\n     24     2      char FieldsArrangement.second                  N/A\\r\\n     26     1   boolean FieldsArrangement.first                   N/A\\r\\n     27     1   boolean FieldsArrangement.fifth                   N/A\\r\\n     28     4           (loss due to the next object alignment)\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## Inne przyk\u0142ady - Sprawdzanie rozmiaru pami\u0119ci dla obiekt\xf3w\\r\\n\\r\\n### Array:\\r\\n\\r\\n- Array boolean\xf3w\\r\\n\\r\\n    ```java\\r\\n    boolean[] booleans = new boolean[3];\\r\\n    System.out.println(ClassLayout.parseInstance(booleans).toPrintable());\\r\\n    System.out.println(GraphLayout.parseInstance(booleans).toFootprint());\\r\\n    /* Output\\r\\n    [Z object internals:\\r\\n     OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n          0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n          4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n          8     4           (object header)                           00 1b 00 00 (00000000 00011011 00000000 00000000) (6912)\\r\\n         12     4           (object header)                           03 00 00 00 (00000011 00000000 00000000 00000000) (3)\\r\\n         16     3   boolean [Z.<elements>                             N/A\\r\\n         19     5           (loss due to the next object alignment)\\r\\n    Instance size: 24 bytes\\r\\n    Space losses: 0 bytes internal + 5 bytes external = 5 bytes total\\r\\n    \\r\\n    [Z@1068e947d footprint:\\r\\n         COUNT       AVG       SUM   DESCRIPTION\\r\\n             1        24        24   [Z\\r\\n             1                  24   (total)\\r\\n    */\\r\\n    ```\\r\\n\\r\\n- Array int\xf3w\\r\\n\\r\\n    ```java\\r\\n    int[] ints = new int[4];\\r\\n    System.out.println(ClassLayout.parseInstance(ints).toPrintable());\\r\\n    System.out.println(GraphLayout.parseInstance(ints).toFootprint());\\r\\n    /* Output\\r\\n    [I object internals:\\r\\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n          0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n          4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n          8     4        (object header)                           a0 26 00 00 (10100000 00100110 00000000 00000000) (9888)\\r\\n         12     4        (object header)                           04 00 00 00 (00000100 00000000 00000000 00000000) (4)\\r\\n         16    16    int [I.<elements>                             N/A\\r\\n    Instance size: 32 bytes\\r\\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\\r\\n    \\r\\n    [I@5f71c76ad footprint:\\r\\n         COUNT       AVG       SUM   DESCRIPTION\\r\\n             1        32        32   [I\\r\\n             1                  32   (total)\\r\\n    */\\r\\n    ```\\r\\n\\r\\n\\r\\n### Pami\u0119\u0107 dla ArrayListy:\\r\\n\\r\\n```java\\r\\nArrayList<Integer> integers = new ArrayList<>();\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n/*\\r\\njava.util.ArrayList@185a6e9d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        16        16   [Ljava.lang.Object;\\r\\n         1        24        24   java.util.ArrayList\\r\\n         2                  40   (total)\\r\\n*/\\r\\nfor(int i=0; i<100000; i++){\\r\\n            integers.add(i);\\r\\n}\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n\\r\\n//output:\\r\\n/*\\r\\njava.util.ArrayList@185a6e9d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1    426856    426856   [Ljava.lang.Object;\\r\\n    100000        16   1600000   java.lang.Integer\\r\\n         1        24        24   java.util.ArrayList\\r\\n    100002             2026880   (total)\\r\\n*/\\r\\n```\\r\\n\\r\\n2 026 880 bytes = 2mb 27kb dla 100 000 int\xf3w. (100 000 * 4=400 000 bytes.)\\r\\nGdy zainicjalizujemy initial capacity ArrayListy to warto\u015b\u0107 pami\u0119ci jest mniejsza o 26880 bytes (26kb)\\r\\n\\r\\n```java\\r\\nArrayList<Integer> integers = new ArrayList<>(100000);\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n/*\\r\\njava.util.ArrayList@179ece50d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1    400016    400016   [Ljava.lang.Object;\\r\\n         1        24        24   java.util.ArrayList\\r\\n         2              400040   (total)\\r\\n*/\\r\\nfor(int i=0; i<100000; i++){\\r\\n            integers.add(i);\\r\\n}\\r\\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\\r\\n/*\\r\\njava.util.ArrayList@179ece50d footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1    400016    400016   [Ljava.lang.Object;\\r\\n    100000        16   1600000   java.lang.Integer\\r\\n         1        24        24   java.util.ArrayList\\r\\n    100002             2000040   (total)\\r\\n*/\\r\\n```\\r\\n\\r\\n### Boolean - Przyk\u0142ad uk\u0142adu pami\u0119ci klasy os\u0142onowej\\r\\n\\r\\n- Boolean 16 bytes - szczeg\xf3\u0142y uk\u0142adu pami\u0119ci poni\u017cej:\\r\\n\\r\\n  Wywo\u0142ujemy lini\u0119 kodu: `System.*out*.println(ClassLayout.*parseClass*(Boolean.class).toPrintable());`\\r\\n\\r\\n  Output:\\r\\n\\r\\n    ```\\r\\n    # WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf\\r\\n    # WARNING: Unable to attach Serviceability Agent. sun.jvm.hotspot.memory.Universe.getNarrowOopBase()\\r\\n    java.lang.Boolean object internals:\\r\\n     OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n          0    12           (object header)                           N/A\\r\\n         12     1   boolean Boolean.value                             N/A\\r\\n         13     3           (loss due to the next object alignment)\\r\\n    Instance size: 16 bytes\\r\\n    Space losses: 0 bytes internal + 3 bytes external = 3 bytes total\\r\\n    ```\\r\\n\\r\\n  Warto\u015b\u0107 danych zajmuje 1 byte (8 bit\xf3w) a nie 1 bit jakby mog\u0142o si\u0119 wydawa\u0107.\\r\\n  12 bytes na metadane + 1 byte na dane booleana + 3 bytes przesuni\u0119cia (aby by\u0142a wielokrotno\u015b\u0107 8)=16byt\xf3w\\r\\n\\r\\n\\r\\n### String - [Obliczanie pami\u0119ci zajmowanej przez String - JOL  Footprint](2024-05-16-String-memory-usage-jvm.md)"},{"id":"regular-expressions","metadata":{"permalink":"/pl/blog/regular-expressions","source":"@site/i18n/pl/docusaurus-plugin-content-blog/2024-05-16-regular-expressions.md","title":"Wyra\u017cenia regularne","description":"W skr\xf3cie","date":"2024-05-16T00:00:00.000Z","formattedDate":"16 maja 2024","tags":[{"label":"others","permalink":"/pl/blog/tags/others"}],"readingTime":2.54,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"regular-expressions","title":"Wyra\u017cenia regularne","authors":"bjab","tags":["others"]},"prevItem":{"title":"Sprawdzenie dok\u0142adnej alokacji pami\u0119ci JVM - biblioteka jol (Java Object Layout)","permalink":"/pl/blog/jvm-memory-allocation-of-objects"},"nextItem":{"title":"Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint","permalink":"/pl/blog/string-in-jvm-memory"}},"content":"## W skr\xf3cie\\r\\n- Sk\u0142ada si\u0119 z sekwencji atom\xf3w (atom to litera\u0142 - litera, cyfra, znak specjalny)\\r\\n- Wielko\u015b\u0107 liter ma znaczenie\\r\\n- Mo\u017cna przetestowa\u0107 regexy w narz\u0119dziach online typu: https://regex101.com/\\r\\n\x3c!-- truncate --\x3e\\r\\n## Kwantyfikatory\\r\\n\\r\\nKwantyfikator m\xf3wi ile mo\u017ce by\u0107 wyst\u0105pie\u0144 danego atomu. Kwantyfikator odnosi si\u0119 do elementu po\u0142o\u017conego po lewej stronie od kwantyfikatora. Je\u017celi przy atomie nie ma kwantyfikatora to oznacza, \u017ce atom b\u0119dzie mia\u0142 jedno wyst\u0105pienie (w przyk\u0142adach poni\u017cej atom `b` ma zawsze jedno wyst\u0105pienie.\\r\\n\\r\\n- `*` - zero lub wi\u0119cej wyst\u0105pie\u0144\\r\\n\\r\\n  np. `a*b` mo\u017ce przek\u0142ada\u0107 si\u0119 mi\u0119dzy innymi na wyra\u017cenia: `b`, `ab`, `aab`, `aaaaaaab`, \u2026\\r\\n\\r\\n- `+` - jedno lub wi\u0119cej wyst\u0105pie\u0144\\r\\n\\r\\n  np. `a+b` mo\u017ce przek\u0142ada\u0107 si\u0119 mi\u0119dzy innymi na wyra\u017cenia: `ab`, `aab`, `aaaaab`, \u2026\\r\\n\\r\\n- `?` - zero lub jedno wyst\u0105pienie\\r\\n\\r\\n  np. `a?b` przek\u0142ada si\u0119 na `b`, `ab`\\r\\n\\r\\n- `{min,max}` - Co najmniej `min` wyst\u0105pie\u0144, a maksymalnie `max` wyst\u0105pie\u0144\\r\\n\\r\\n  np. `a{2,4}b` przek\u0142ada si\u0119 na wyra\u017cenia: `aab`, `aaab`, `aaaab`\\r\\n\\r\\n- `{min,}` - Co najmniej `min` wyst\u0105pie\u0144. Maksymalnie mo\u017ce by\u0107 niesko\u0144czenie wiele.\\r\\n- `{,max}` - Nie ma minimalnej liczby wyst\u0105pie\u0144, a maksymalnie mo\u017ce by\u0107 `max` wyst\u0105pie\u0144\\r\\n- `{n}` - dok\u0142adna liczba wyst\u0105pie\u0144 r\xf3wna `n`\\r\\n\\r\\n  np. `a{4}b` - przek\u0142ada si\u0119 na: `aaaab`\\r\\n\\r\\n\\r\\n## Zakresy []\\r\\n\\r\\nZakres oznacza, \u017ce wyra\u017cenie mo\u017ce by\u0107 jedn\u0105 liter\u0105/cyfr\u0105 z zakresu. My\u015blnik `-` oznacza zakres od, do.\\r\\n\\r\\n- `[abc]` - oznacza, \u017ce wyra\u017ceniem b\u0119dzie `a` lub `b` lub `c` (tylko jedna litera)\\r\\n- `[a-bB-Z]` - wyra\u017ceniem mo\u017ce by\u0107 `a`, `b`, `B`, `C`, `D`, \u2026, `Z`\\r\\n- `[a-Z]` - wyra\u017ceniem mo\u017ce by\u0107 ka\u017cdy angloj\u0119zyczny znak (du\u017cy lub ma\u0142y)\\r\\n- `[0-9]` - wyra\u017ceniem mo\u017ce by\u0107 ka\u017cda cyfra\\r\\n- `[a-Z\u0105\u0107\u0119\u0142\u0144\xf3\u015b\u017a\u017c\u0104\u0118\u0141\u0143\xd3\u015a\u0179\u017b]` - zakres wszystkich polskich znak\xf3w.\\r\\n\\r\\n## Grupy ()\\r\\n\\r\\n- `(ab){2}` - oznacza wyra\u017cenie `abab`\\r\\n\\r\\n## Flagi\\r\\n\\r\\n- `(?i)` - ignorowanie wielko\u015bci liter z prawej strony od tego znaku\\r\\n\\r\\n## Znaki specjalne\\r\\n\\r\\n- `.` - ka\u017cdy znak\\r\\n- `$` - koniec wiersza (je\u015bli u\u017cyjemy ten znak na ko\u0144cu to oznacza, \u017ce nie ma \u017cadnego znaku po poszukiwanym wyra\u017ceniu.\\r\\n- `^` - pocz\u0105tek wiersza (je\u015bli u\u017cyjemy ten znak na pocz\u0105tku to oznacza, \u017ce nie ma \u017cadnego znaku przed poszukiwanym wyra\u017ceniem.\\r\\n- `[^e]` - negacja - wyra\u017cenie nie b\u0119dzie zawiera\u0142o litery `e`.\\r\\n- `|` - znak oznacza logiczne lub, czyli wyra\u017ceniem b\u0119dzie dowolne wyra\u017cenie oddzielone znakiem `|`\\r\\n\\r\\n  np. `a|b` - oznacza `a` lub `b`\\r\\n\\r\\n- `\\\\s` - Spacja, tabulator lub znak nowego wiersza\\r\\n- `\\\\S` - Znak kt\xf3ry jest negacj\u0105 `\\\\s`, czyli znak, kt\xf3ry nie jest spacj\u0105, tabulatorem lub znakiem nowego wiersza\\r\\n- `\\\\w` - litera, cyfra lub znak `_` (zapis r\xf3wnowa\u017cny do `[a-Z_]`\\r\\n- `\\\\W` - znak kt\xf3ry jest negacj\u0105 `\\\\w` czyli taki znak, kt\xf3ry nie jest liter\u0105, cyfr\u0105 lub znakiem `_`\\r\\n- `\\\\d` - cyfra (digit) (zapis r\xf3wnowa\u017cny do `[0-9]`)\\r\\n- `\\\\D` - znak kt\xf3ry jest negacj\u0105 `\\\\d` czyli taki znak, kt\xf3ry nie jest cyfr\u0105\\r\\n- `\\\\b` - Dowolny znak odst\u0119pu, pocz\u0105tku \u0142ancucha, ko\u0144ca \u0142a\u0144cucha oraz dowolnego znaku, kt\xf3ry nie jest ani liter\u0105 ani cyfr\u0105.\\r\\n\\r\\n**Je\u017celi chcemy u\u017cy\u0107 w wyra\u017ceniu regularnym jednego ze znak\xf3w specjalnych takich jak `.`, `*`, `/`, `?`, `:`, `.`, `^`, `+`, `\\\\`, `=`, `|`, to poprzedzamy go znakiem `\\\\` czyli np. `\\\\.`**"},{"id":"string-in-jvm-memory","metadata":{"permalink":"/pl/blog/string-in-jvm-memory","source":"@site/i18n/pl/docusaurus-plugin-content-blog/2024-05-16-String-memory-usage-jvm.md","title":"Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint","description":"W skr\xf3cie:","date":"2024-05-16T00:00:00.000Z","formattedDate":"16 maja 2024","tags":[{"label":"jvm","permalink":"/pl/blog/tags/jvm"},{"label":"jol","permalink":"/pl/blog/tags/jol"},{"label":"string","permalink":"/pl/blog/tags/string"},{"label":"heap","permalink":"/pl/blog/tags/heap"},{"label":"memory","permalink":"/pl/blog/tags/memory"}],"readingTime":6.27,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"string-in-jvm-memory","title":"Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint","authors":"bjab","tags":["jvm","jol","string","heap","memory"]},"prevItem":{"title":"Wyra\u017cenia regularne","permalink":"/pl/blog/regular-expressions"},"nextItem":{"title":"\u015aci\u0105gaj Playlisty z YouTube bez reklam za darmo - za pomoc\u0105 prostego skryptu","permalink":"/pl/blog/python-youtube-downloader"}},"content":"## W skr\xf3cie:\\r\\n\\r\\n- Na pami\u0119\u0107 obiektu String sk\u0142ada si\u0119 24 byte na metadane + ilo\u015b\u0107 znak\xf3w razy 1 byte lub 2 byte w zale\u017cno\u015bci od warto\u015bci coder\\r\\n    - Metadane : mark word x2 (4 bytes x2 = 8 bytes), klass word (4 bytes), referencja do tablicy byte[] lub char[] (4 byte), hash (4 byte), hashIsZero (1 byte), coder (1 byte),  padding (2 byte)\\r\\n- Obiekt String ma 2 dodatkowe flagi:\\r\\n    - gdy `coder =1` to kodowanie UTF-16 (2 bytes na znak)\\r\\n    - gdy `coder = 0` to kodowanie LATIN-1 (1 byte na znak)\\r\\n    - hashIsZero jest to flaga kt\xf3ra m\xf3wi czy obliczenie hasha zosta\u0142o ju\u017c wykonane\\r\\n\x3c!-- truncate --\x3e\\r\\n\\r\\n## JOL - String\\r\\n\\r\\nOd Java 9 u\u017cywamy Compact String czyli je\u015bli to mo\u017cliwe to u\u017cywamy kodowania LATIN-1 a jak nie to ustawiany jest coder=1 i u\u017cywamy UTF-16.\\r\\n\\r\\n(Przed Java 9 wszystko sprowadza\u0142o si\u0119 do char[] i ka\u017cda literka by\u0142a r\xf3wna 2 byte Utf-16.)\\r\\n\\r\\nJe\u015bli chocia\u017c jeden znak b\u0119dzie inny ni\u017c latin-1 (1 byte) to ka\u017cdy znak w Stringu jest kodowany w utf16 (2 byte).\\r\\n\\r\\n```java\\r\\nString utf16String = \\"Bartosz Jab\u0142o\u0144ski\\"; // 17 znak\xf3w x 2 bytes = 34 bytes\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String).toPrintable());\\r\\nSystem.out.println(GraphLayout.parseInstance(utf16String).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String.getBytes()).toPrintable());\\r\\nSystem.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());\\r\\n       \\r\\nString latin1String = \\"Bartosz Jablonski\\"; // 17 znak\xf3w x 1 bytes = 17 bytes\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String).toPrintable());\\r\\nSystem.out.println(GraphLayout.parseInstance(latin1String).toFootprint());\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());\\r\\nSystem.out.println(ClassLayout.parseInstance(latin1String.toCharArray()).toPrintable());\\r\\n```\\r\\n\\r\\n```\\r\\n#### Bartosz Jab\u0142o\u0144ski - UTF-16 - coder:1\\r\\njava.lang.String object internals:\\r\\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\\r\\n     12     4       int String.hash                               0\\r\\n     16     1      byte String.coder                              1\\r\\n     17     1   boolean String.hashIsZero                         false\\r\\n     18     2           (alignment/padding gap)                  \\r\\n     20     4    byte[] String.value                              [66, 0, 97, 0, 114, 0, 116, 0, 111, 0, 115, 0, 122, 0, 32, 0, 74, 0, 97, 0, 98, 0, 66, 1, 111, 0, 68, 1, 115, 0, 107, 0, 105, 0]\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\\r\\n\\r\\njava.lang.String@7dc222aed footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        56        56   [B\\r\\n         1        24        24   java.lang.String\\r\\n         2                  80   (total)\\r\\n\\r\\n[B object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\\r\\n     12     4        (object header)                           13 00 00 00 (00010011 00000000 00000000 00000000) (19)\\r\\n     16    19   byte [B.<elements>                             N/A\\r\\n     35     5        (loss due to the next object alignment)\\r\\nInstance size: 40 bytes\\r\\nSpace losses: 0 bytes internal + 5 bytes external = 5 bytes total\\r\\n\\r\\n[C object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    34   char [C.<elements>                             N/A\\r\\n     50     6        (loss due to the next object alignment)\\r\\nInstance size: 56 bytes\\r\\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\\r\\n```\\r\\n\\r\\nW pierwszym przypadku dla `Bartosz Jab\u0142o\u0144ski` gdzie zawarli\u015bmy polskie znaki niezawieraj\u0105ce si\u0119 w LATIN-1 wida\u0107, \u017ce String ma flag\u0119 `coder` ustawion\u0105 na `1` czyli u\u017cywa kodowania typu `UTF-16` (2 byte per znak).\\r\\n\\r\\nFootprint pokazuje deep size obiektu String (17 znakowy) wynosi 80 bytes. Na to sk\u0142ada si\u0119 String i jego metadane i pod obiekt Stringa czyli tablica char[] w kodowaniu UTF-16 (2byte per znak).\\r\\nPodsumowuj\u0105c:\\r\\n\\r\\n- 24 bytes - String z referencj\u0105 zajmuje 24 bytes (12 bytes na metadane (headery) + 4 bytes na hash(int) + 1 byte na coder, + 1 byte na hashIsZero + 4 bytes referencji do tablicy char\xf3w  + 2 byte na alligment padding).\\r\\n    - Gdzie coder odpowiada za:\\r\\n\\r\\n\\r\\n        Jest to warto\u015b\u0107 zwi\u0105zana \u015bci\u015ble z implementacj\u0105 JVM (hotspot). Jest to identyfikator kodowania u\u017cywany do kodowania bajt\xf3w. Obs\u0142ugiwane warto\u015bci to LATIN1 (coder=0) i UTF16(coder=1).\\r\\n        Je\u015bli chocia\u017c jedna literka **nie zawiera si\u0119 w LATIN1** to coder=1 i ca\u0142y String b\u0119dzie kodowany do UTF-16 czyli w pami\u0119ci zajmie (n literek * 2 bytes).\\r\\n        \\r\\n    - Gdzie hashIsZero odpowiada za:\\r\\n        \\r\\n        \\r\\n        To pole m\xf3wi JVM czy mo\u017cna omin\u0105\u0107 ponownemu obliczaniu hashu. (taki rodzaj cachu)\\r\\n\\r\\n- 56 bytes - Tablica byte[] zajmuje 56 bytes na co sk\u0142ada si\u0119: 12 byte metadanych (header\xf3w) + 4 byte metadane dotycz\u0105ce tablicy (length) + dane 17 znak\xf3w * 2 byte (34 byte) = 50 byte + 6 byt\xf3w na wyr\xf3wnanie. Obrazuje to nieintuicyjnie linia kodu: `System.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());`\\r\\n\\r\\n```java\\r\\n#### Bartosz Jablonski - LATIN-1 - coder:0\\r\\njava.lang.String object internals:\\r\\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\\r\\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\\r\\n     12     4       int String.hash                               0\\r\\n     16     1      byte String.coder                              0\\r\\n     17     1   boolean String.hashIsZero                         false\\r\\n     18     2           (alignment/padding gap)                  \\r\\n     20     4    byte[] String.value                              [66, 97, 114, 116, 111, 115, 122, 32, 74, 97, 98, 108, 111, 110, 115, 107, 105]\\r\\nInstance size: 24 bytes\\r\\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\\r\\n\\r\\njava.lang.String@48a242ced footprint:\\r\\n     COUNT       AVG       SUM   DESCRIPTION\\r\\n         1        40        40   [B\\r\\n         1        24        24   java.lang.String\\r\\n         2                  64   (total)\\r\\n\\r\\n[B object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    17   byte [B.<elements>                             N/A\\r\\n     33     7        (loss due to the next object alignment)\\r\\nInstance size: 40 bytes\\r\\nSpace losses: 0 bytes internal + 7 bytes external = 7 bytes total\\r\\n\\r\\n[C object internals:\\r\\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\\r\\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\\r\\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\\r\\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\\r\\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\\r\\n     16    34   char [C.<elements>                             N/A\\r\\n     50     6        (loss due to the next object alignment)\\r\\nInstance size: 56 bytes\\r\\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\\r\\n```\\r\\n\\r\\nW drugim przypadku dla `Bartosz Jablonski` gdzie nie zawarli\u015bmy polskich znak\xf3w, wida\u0107, \u017ce String ma flag\u0119 coder ustawion\u0105 na 0 czyli u\u017cywa kodowania typu LATIN-1 (1 byte per znak).\\r\\n\\r\\nFootprint pokazuje deep size obiektu String (17 znakowy) wynosi 64 bytes. Na to sk\u0142ada si\u0119 String i jego metadane i pod obiekt Stringa czyli tablica byte[] w kodowaniu LATIN-1 (1 byte per znak) .\\r\\n\\r\\n- String z referencj\u0105 zajmuje 24 bytes (12 bytes na metadane (headery) + 4 bytes na hash(int) + 1 byte na coder + 1 byte na hashIsZero + 4 bytes referencji do tablicy byt\xf3w + 2 byte na alligment padding).\\r\\n- Tablica byte[] zajmuje 40 bytes na co sk\u0142ada si\u0119: 12 byte metadanych (header\xf3w) + 4 byte metadane dotycz\u0105ce tablicy (length) + dane 17 znak\xf3w * 1 byte (17 byte) = 33 byte + 7 byt\xf3w na wyr\xf3wnanie.\\r\\n\\r\\nObrazuje to linia kodu: `System.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());`\\r\\n\\r\\nDzi\u0119ki fladze `coder` i braku znak\xf3w specjalnych mamy zysk w mniejszej ilo\u015bci zajmowanej pami\u0119ci r\xf3wny 16 byt\xf3w - co dzieje si\u0119 bez naszej ingerencji programistycznej."},{"id":"python-youtube-downloader","metadata":{"permalink":"/pl/blog/python-youtube-downloader","source":"@site/i18n/pl/docusaurus-plugin-content-blog/2024-05-16-youtube-downloader.md","title":"\u015aci\u0105gaj Playlisty z YouTube bez reklam za darmo - za pomoc\u0105 prostego skryptu","description":"Ostatnio zrezygnowa\u0142em z Spotify Premium i s\u0142uchanie muzyki oraz podcast\xf3w w samolocie sta\u0142o si\u0119 trudniejsze. Do tej pory \u015bci\u0105ga\u0142em mp3 i mp4 za pomoc\u0105 narz\u0119dzi online typu:","date":"2024-05-16T00:00:00.000Z","formattedDate":"16 maja 2024","tags":[{"label":"python","permalink":"/pl/blog/tags/python"},{"label":"scripts","permalink":"/pl/blog/tags/scripts"},{"label":"tools","permalink":"/pl/blog/tags/tools"}],"readingTime":3.165,"hasTruncateMarker":true,"authors":[{"name":"Bartek Jab\u0142o\u0144ski","title":"Backend Cloud Developer","url":"https://bartas93.github.io","imageURL":"/images/bartek_jablonski_2.png","key":"bjab"}],"frontMatter":{"slug":"python-youtube-downloader","title":"\u015aci\u0105gaj Playlisty z YouTube bez reklam za darmo - za pomoc\u0105 prostego skryptu","authors":"bjab","tags":["python","scripts","tools"]},"prevItem":{"title":"Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint","permalink":"/pl/blog/string-in-jvm-memory"}},"content":"Ostatnio zrezygnowa\u0142em z Spotify Premium i s\u0142uchanie muzyki oraz podcast\xf3w w samolocie sta\u0142o si\u0119 trudniejsze. Do tej pory \u015bci\u0105ga\u0142em mp3 i mp4 za pomoc\u0105 narz\u0119dzi online typu:\\r\\n\\r\\n- https://notube.net/pl/youtube-app-v103\\r\\n- https://y2down.cc/pl/youtube-mp4.html i inne\\r\\n\\r\\nNiestety narz\u0119dzia tego typu pozwalaj\u0105 na \u015bci\u0105ganie pojedynczych film\xf3w i zarzucaj\u0105 nas mas\u0105 inwazyjnych reklam. Aby omin\u0105\u0107 te problemy, napiszemy skrypt w j\u0119zyku python, kt\xf3ry po podaniu linku do playlisty lub filmu \u015bci\u0105gnie nam mp3 lub mp4.\\r\\n\\r\\nDo napisania skryptu u\u017cyjemy bibliotek\u0119 [pytube](https://pytube.io/en/latest/).\\r\\n\\r\\nCa\u0142y skrypt mo\u017cecie znale\u017a\u0107 w repozytorium gitlab: https://gitlab.com/bart_as93/youtube-downloader\\r\\n\x3c!-- truncate --\x3e\\r\\n### 1. Konfiguracja wst\u0119pna\\r\\n\\r\\nPobierz repozytorium na lokaln\u0105 maszyn\u0119:\\r\\n\\r\\n```bash\\r\\ngit clone https://gitlab.com/bart_as93/youtube-downloader.git\\r\\ncd youtube-downloader\\r\\n```\\r\\n\\r\\nSprawd\u017a wersje pythona\\r\\n\\r\\n```bash\\r\\npython --version\\r\\n```\\r\\n\\r\\nW moim przypadku `Python 3.11.4`\\r\\n\\r\\nNast\u0119pnie instalujemy zale\u017cno\u015bci\\r\\n\\r\\n```bash\\r\\npip install -r requirements.txt\\r\\n```\\r\\n\\r\\nNast\u0119pnie uruchamiamy skrypt np.:\\r\\n\\r\\n```bash\\r\\npython .\\\\downloader.py -u https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d music -f mp4\\r\\n```\\r\\n\\r\\nSkrypt przyjmuje 4 argumenty:\\r\\n\\r\\n- `-f` - jeden z format\xf3w: mp3 albo mp4\\r\\n- `-d` - docelowy folder w kt\xf3rym maj\u0105 znajdowa\u0107 si\u0119 \u015bci\u0105gni\u0119te pliki\\r\\n- i jedno z po\u017cniszych:\\r\\n  - `-u` - Url do wideo na platformie YouTube\\r\\n  - `-pu` - Url do playlisty na platformie Youtube\\r\\n\\r\\n### Pobieranie YouTube video w formacie mp4\\r\\n\\r\\nAby \u015bci\u0105gn\u0105\u0107 film YouTube trzeba u\u017cy\u0107 flagi `-u <link_do_filmu>` oraz flag\u0119 `-f mp4`\\r\\n\\r\\n```bash\\r\\npython .\\\\downloader.py -u https://www.youtube.com/watch?v=a59gmGkq_pw -d movies -f mp4\\r\\n```\\r\\n\\r\\n### Pobieranie YouTube video w formacie mp3\\r\\n\\r\\nAby \u015bci\u0105gn\u0105\u0107 audio z YouTube trzeba u\u017cy\u0107 flagi `-u <link_do_filmu>` oraz flag\u0119 `-f mp3`\\r\\n\\r\\n```bash\\r\\npython .\\\\downloader.py -u https://www.youtube.com/watch?v=a59gmGkq_pw -d music -f mp3\\r\\n```\\r\\n\\r\\n### Pobieranie playlisty YouTube w formacie mp4\\r\\n\\r\\nAby \u015bci\u0105gn\u0105\u0107 filmy z Playlisty YouTube trzeba u\u017cy\u0107 flagi `-pu <link_do_playlisty>` oraz flag\u0119 `-f mp4`\\r\\n\\r\\n```bash\\r\\npython .\\\\downloader.py -pu https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d music-f mp4\\r\\n```\\r\\n\\r\\n### Pobieranie YouTube Playlist w formacie mp3\\r\\n\\r\\nAby \u015bci\u0105gn\u0105\u0107 audio z Playlisty YouTube trzeba u\u017cy\u0107 flagi `-pu <link_do_playlisty>` oraz flag\u0119 `-f mp3`\\r\\n\\r\\n```bash\\r\\npython .\\\\downloader.py -pu https://www.youtube.com/playlist?list=PLRomwVsNGznFggOY71VFRH_Wi8IOXj3hb -d movies -f mp3\\r\\n```\\r\\n\\r\\n## Om\xf3wienie kodu (komentarze):\\r\\n\\r\\n```python\\r\\nimport argparse\\r\\nimport os\\r\\nfrom pytube import Playlist\\r\\nfrom pytube import YouTube\\r\\n\\r\\n# Program obs\u0142uguje 2 formaty mp3 i mp4. W sekcji else przy innym formacie program jest wy\u0142\u0105czany\\r\\ndef downloadByVideo(vid):\\r\\n    print(\'downloading : {} - {} with url : {}\'.format(video.author, video.title, video.watch_url))\\r\\n    global type\\r\\n    vidFileName = vid.author + \\" - \\" + vid.title + \\".\\" + format\\r\\n    if format == \'mp3\':\\r\\n        type = \'audio\'\\r\\n# Na obiekcie video odwo\u0142ujemy si\u0119 do streams, filtrujemy tylko audio i wywo\u0142ujemy metod\u0119 download z opcjami opisuj\u0105cymi docelowy katalog w kt\xf3rym zostanie zapisany plik oraz nazw\u0119 pliku\\r\\n        vid.streams. \\\\\\r\\n            filter(only_audio=True).desc().first(). \\\\\\r\\n            download(output_path=DOWNLOAD_DIR, filename=vidFileName)\\r\\n    elif format == \'mp4\':\\r\\n        type = \'video\'\\r\\n# Na obiekcie video odwo\u0142ujemy si\u0119 do streams, filtrujemy tylko video, sortujemy od najwi\u0119kszego resolution i wywo\u0142ujemy metod\u0119 download z opcjami opisuj\u0105cymi docelowy katalog w kt\xf3rym zostanie zapisany plik oraz nazw\u0119 pliku\\r\\n        vid.streams. \\\\\\r\\n            filter(type=type, progressive=True, file_extension=format). \\\\\\r\\n            order_by(\'resolution\'). \\\\\\r\\n            desc(). \\\\\\r\\n            first(). \\\\\\r\\n            download(output_path=DOWNLOAD_DIR, filename=vidFileName)\\r\\n    else:\\r\\n        print(f\\"Not supported format type: {format}\\")\\r\\n        exit()\\r\\n\\r\\n# Obs\u0142uga parametr\xf3w command line i sprawdzenie wymaganych p\xf3l\\r\\nparser = argparse.ArgumentParser()\\r\\n\\r\\nparser.add_argument(\\"-u\\", \\"--Url\\", help=\\"Youtube video url\\")\\r\\nparser.add_argument(\\"-pu\\", \\"--PlayListUrl\\", help=\\"Playlist url\\")\\r\\nparser.add_argument(\\"-f\\", \\"--Format\\", help=\\"Format of downloaded files - mp3 or mp4\\")\\r\\nparser.add_argument(\\"-d\\", \\"--Destination\\", help=\\"Destination folder of downloaded files\\")\\r\\n\\r\\nformat=\\"mp3\\"\\r\\n\\r\\nargs = parser.parse_args()\\r\\n\\r\\nif not args.Url and not args.PlayListUrl:\\r\\n    print(\\"Please provide youtube playlist url via -pu or --PlayListUrl argument param or Youtube video url via -u or --Url\\")\\r\\n    exit()\\r\\nif not args.Destination:\\r\\n    print(\\"Please provide destination folder name via -d or --Destination argument param\\")\\r\\n    exit()\\r\\nif not args.Format:\\r\\n    print(\\"Format (-f or --Format not provided - default set to mp3\\")\\r\\nelse:\\r\\n    format=args.Format\\r\\n\\r\\nDOWNLOAD_DIR = os.getcwd() + \\"\\\\\\\\out\\\\\\\\\\" + args.Destination\\r\\n\\r\\n# Sprawdzamy czy wprowadzony zosta\u0142 url do Playlisty (-pu) czy url do filmu (-u) i na podstawie url \u015bci\u0105gany jest film lub playlista\\r\\nif(args.PlayListUrl):\\r\\n    playlist = Playlist(args.PlayListUrl)\\r\\n    print (f\\"Downloading {len(playlist.videos)} files from playlist with url: {args.Url}, with format: {args.Format}, to dir: {DOWNLOAD_DIR}\\")\\r\\n\\r\\n    for video in playlist.videos:\\r\\n        downloadByVideo(video)\\r\\n\\r\\nif (args.Url):\\r\\n    video = YouTube(args.Url)\\r\\n    downloadByVideo(video)\\r\\n```"}]}')}}]);