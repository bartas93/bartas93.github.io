"use strict";(self.webpackChunkbj_blog=self.webpackChunkbj_blog||[]).push([[3528],{8860:(e,a,n)=>{n.d(a,{xA:()=>y,yg:()=>b});var t=n(7953);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function r(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):r(r({},a),e)),n},y=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,y=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,b=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?t.createElement(b,r(r({ref:a},y),{},{components:n})):t.createElement(b,r({ref:a},y))}));function b(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return t.createElement.apply(null,r)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3548:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var t=n(3911),i=(n(7953),n(8860));const o={slug:"jvm-memory-allocation-of-objects",title:"Sprawdzenie dok\u0142adnej alokacji pami\u0119ci JVM - biblioteka jol (Java Object Layout)",authors:"bjab",tags:["jvm","jol","heap","memory","references"]},r=void 0,l={permalink:"/pl/blog/jvm-memory-allocation-of-objects",source:"@site/i18n/pl/docusaurus-plugin-content-blog/2024-05-16-jvm-memory-allocation-of-objects.md",title:"Sprawdzenie dok\u0142adnej alokacji pami\u0119ci JVM - biblioteka jol (Java Object Layout)",description:"W skr\xf3cie",date:"2024-05-16T00:00:00.000Z",formattedDate:"16 maja 2024",tags:[{label:"jvm",permalink:"/pl/blog/tags/jvm"},{label:"jol",permalink:"/pl/blog/tags/jol"},{label:"heap",permalink:"/pl/blog/tags/heap"},{label:"memory",permalink:"/pl/blog/tags/memory"},{label:"references",permalink:"/pl/blog/tags/references"}],readingTime:13.175,hasTruncateMarker:!0,authors:[{name:"Bartek Jab\u0142o\u0144ski",title:"Backend Cloud Developer",url:"https://bartas93.github.io",imageURL:"/images/bartek_jablonski_2.png",key:"bjab"}],frontMatter:{slug:"jvm-memory-allocation-of-objects",title:"Sprawdzenie dok\u0142adnej alokacji pami\u0119ci JVM - biblioteka jol (Java Object Layout)",authors:"bjab",tags:["jvm","jol","heap","memory","references"]},nextItem:{title:"Wyra\u017cenia regularne",permalink:"/pl/blog/regular-expressions"}},s={authorsImageUrls:[void 0]},p=[{value:"W skr\xf3cie",id:"w-skr\xf3cie",level:2},{value:"Konfiguracja",id:"konfiguracja",level:2},{value:"Dost\u0119pne metody",id:"dost\u0119pne-metody",level:2},{value:"Detale VM - <code>VM.current().details()</code> - Podstawowe dane zwi\u0105zane z nasz\u0105 JVM",id:"detale-vm---vmcurrentdetails---podstawowe-dane-zwi\u0105zane-z-nasz\u0105-jvm",level:3},{value:"Typy okre\u015ble\u0144 zajmowanej pami\u0119ci:",id:"typy-okre\u015ble\u0144-zajmowanej-pami\u0119ci",level:2},{value:"Uk\u0142ad klasy - ClassLayout (shallow size)",id:"uk\u0142ad-klasy---classlayout-shallow-size",level:3},{value:"<strong>Metadane:</strong>",id:"metadane",level:3},{value:"Footprint (Deep size)",id:"footprint-deep-size",level:3},{value:"Compressed vs Uncompressed References",id:"compressed-vs-uncompressed-references",level:3},{value:"Powy\u017cej 32 GB",id:"powy\u017cej-32-gb",level:3},{value:"Co to jest padding/alligment gap (internal space losses)",id:"co-to-jest-paddingalligment-gap-internal-space-losses",level:3},{value:"Field Packing - Upakowanie p\xf3l",id:"field-packing---upakowanie-p\xf3l",level:3},{value:"Inne przyk\u0142ady - Sprawdzanie rozmiaru pami\u0119ci dla obiekt\xf3w",id:"inne-przyk\u0142ady---sprawdzanie-rozmiaru-pami\u0119ci-dla-obiekt\xf3w",level:2},{value:"Array:",id:"array",level:3},{value:"Pami\u0119\u0107 dla ArrayListy:",id:"pami\u0119\u0107-dla-arraylisty",level:3},{value:"Boolean - Przyk\u0142ad uk\u0142adu pami\u0119ci klasy os\u0142onowej",id:"boolean---przyk\u0142ad-uk\u0142adu-pami\u0119ci-klasy-os\u0142onowej",level:3},{value:"String - Obliczanie pami\u0119ci zajmowanej przez String - JOL  Footprint",id:"string---obliczanie-pami\u0119ci-zajmowanej-przez-string---jol--footprint",level:3}],y={toc:p},m="wrapper";function c(e){let{components:a,...o}=e;return(0,i.yg)(m,(0,t.A)({},y,o,{components:a,mdxType:"MDXLayout"}),(0,i.yg)("h2",{id:"w-skr\xf3cie"},"W skr\xf3cie"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Ka\u017cdy obiekt ma narzut pami\u0119ci (metadane) (12-16 bajt\xf3w na metadane - referencja, headery + pami\u0119\u0107 na dane)."),(0,i.yg)("li",{parentName:"ul"},"Procesory (CPU) mog\u0105 by\u0107 32 bitowe (4 byte - maxymalnie 4 GB pami\u0119ci RAM) lub 64 bitowe (8 byte). To oznacza tyle, \u017ce CPU ma dost\u0119p do ty\u0142u adres\xf3w ile mo\u017cna zapisa\u0107 w 4 lub 8 bytach. Dodatkowo CPU pobiera paczkami dane z RAM po 8 byt\xf3w naraz."),(0,i.yg)("li",{parentName:"ul"},"Padding - wyr\xf3wnanie do 8 bajt\xf3w - czyli obiekty zajmuj\u0105 pami\u0119\u0107 r\xf3wn\u0105 wielokrotno\u015bci 8 bajt\xf3w. Mo\u017cna to zwi\u0119kszy\u0107 bo ogranicza to u\u017cycie maksymalnego heapa na poziomie 32 GB."),(0,i.yg)("li",{parentName:"ul"},"Referencja zajmuje 4 (32bit CPU lub 64bit CPU z Compressed References (default)) lub 8 bajt\xf3w (64bit CPU).",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Maksymalny heap dla Compressed References = 32 GB - wykorzystanie przesuni\u0119cia bitowego o 3 miejsca ze wzgl\u0119du na to \u017ce zapis 8 byte zawsze po prawej stronie ma trzy zera. (8 byte bo jest wyr\xf3wnanie do 8 byt\xf3w). Dlatego mo\u017cemy u\u017cy\u0107 32 GB heapa zamiast 4 GB."),(0,i.yg)("li",{parentName:"ul"},"Gdy u\u017cywamy 64bit CPU z Compressed References i zwi\u0119kszymy Pami\u0119\u0107 heapa powy\u017cej 32 GB mo\u017cemy mie\u0107 problemy z aplikacj\u0105 i znacz\u0105cy wzrost zajmowanego heapa ze wzgl\u0119du na zmian\u0119 pami\u0119ci referencji z 4 bytes do 8 bytes - np. zmiana z -Xmx31g do -Xmx33g mo\u017ce spowodowa\u0107 wzrost zaj\u0119cia danych o 40% (w zale\u017cno\u015bci od danych)")))),(0,i.yg)("h2",{id:"konfiguracja"},"Konfiguracja"),(0,i.yg)("p",null,"Aby sprawdzi\u0107 jak wygl\u0105da uk\u0142ad pami\u0119ci (memory layout) u\u017cyjemy biblioteki:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-xml"},"<dependency>\n    <groupId>org.openjdk.jol</groupId>\n    <artifactId>jol-core</artifactId>\n    <version>0.10</version>\n</dependency>\n")),(0,i.yg)("p",null,"Jol to taki toolbox do analizowania uk\u0142adu obiekt\xf3w w JVM. Te narz\u0119dzia u\u017cywaj\u0105 (w celu dekodowania rzeczywistego uk\u0142adu obiektu (object layout), jego zajmowanej pami\u0119ci (footprint) i referencji (references)). Jol u\u017cywa takich narz\u0119dzi jak:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Unsafe"),(0,i.yg)("li",{parentName:"ul"},"JVMTI"),(0,i.yg)("li",{parentName:"ul"},"Serviceability Agent (SA)")),(0,i.yg)("h2",{id:"dost\u0119pne-metody"},"Dost\u0119pne metody"),(0,i.yg)("h3",{id:"detale-vm---vmcurrentdetails---podstawowe-dane-zwi\u0105zane-z-nasz\u0105-jvm"},"Detale VM - ",(0,i.yg)("inlineCode",{parentName:"h3"},"VM.current().details()")," - Podstawowe dane zwi\u0105zane z nasz\u0105 JVM"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"# Running 64-bit HotSpot VM.\n# Using compressed oop with 3-bit shift.\n# Using compressed klass with 3-bit shift.\n# WARNING | Compressed references base/shifts are guessed by the experiment!\n# WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\n# WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\n# Objects are 8 bytes aligned.\n# Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n# Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Uruchamiamy nasz program na ",(0,i.yg)("strong",{parentName:"p"},"64")," bitowej wersji ",(0,i.yg)("strong",{parentName:"p"},"JVM \u2013 HotSpot"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"Using compressed oop with 3-bit shift.")," - ",(0,i.yg)("a",{parentName:"p",href:"#compressed-vs-uncompressed-references"},"wi\u0119cej"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"Using compressed klass with 3-bit shift.")," - ",(0,i.yg)("a",{parentName:"p",href:"#compressed-vs-uncompressed-references"},"wi\u0119cej"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"Objects are 8 bytes aligned.")," - Obiekty b\u0119d\u0105 wyr\xf3wnane do ",(0,i.yg)("strong",{parentName:"p"},"8")," bajt\xf3w - oznacza to tyle, \u017ce ka\u017cdy obiekt nawet jak powinien zajmowa\u0107 20 byt\xf3w to i tak zajmuje wielokrotno\u015b\u0107 8 bajt\xf3w czyli w tym przypadku 24 bajty. Zawsze idzie w g\xf3r\u0119 do wielokrotno\u015bci 8 bajt\xf3w.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Dlaczego?\nProcesory s\u0105 32 lub 64 bitowe (32 bit CPU mo\u017ce u\u017cy\u0107 max 4 GB pami\u0119ci). Czyli 4 lub 8 bytowe. Co oznacza, \u017ce odczytuj\u0105 (z rejestru pami\u0119ci poprzez zewn\u0119trzn\u0105 magistral\u0119) po 4 lub 8 byt\xf3w pami\u0119ci naraz. CPU nie pobiera pojedynczych bit\xf3w lub byt\xf3w. Pobiera paczkami. Jest to spowodowane tym \u017ce CPU (np. 3GHz) jest szybsze ni\u017c pami\u0119\u0107 (400MHz). Wykorzystuj\u0105c to \u017ce CPU jest szybsze pobieramy paczkami dane. Aby u\u0142atwi\u0107 (i przyspieszy\u0107) to wyci\u0105ganie danych, JVM grupuje te dane po 8 byt\xf3w dla 64 bitowej maszyny (czyli wi\u0119kszo\u015b\u0107 wsp\xf3\u0142czesnych).")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Mo\u017cna to zmieni\u0107 flag\u0105 JVM: ",(0,i.yg)("inlineCode",{parentName:"p"},"*-XX:ObjectAlignmentInBytes=16")," (Dost\u0119pne warto\u015bci 8,16,32,64,128,256, inaczej JVM rzuci b\u0142\u0105d i nie uruchomi aplikacji). Flaga, przez kt\xf3r\u0105 wi\u0119kszo\u015b\u0107 obiekt\xf3w b\u0119dzie zajmowa\u0142o du\u017co wi\u0119cej nieu\u017cytej pami\u0119ci. Zal\u0119t\u0105 tego rozwi\u0105zania jest \u017ce mo\u017cemy wtedy u\u017cy\u0107 64 GB Heap z skompresowanymi referencjami. (Poniewa\u017c 3 bit shifting zmieni si\u0119 na 4 bit shifting - 16 byte zawsze ma 4 zera po prawej stronie)*")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Nast\u0119pnie s\u0105 pokazane rozmiary typ\xf3w w naszej JVM")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Referencja obiektu: 4 bytes - w tym przypadku jest w\u0142\u0105czona domy\u015blnie flaga Compressed References - dlatego w 64 bitowej JVM referencja zajmuje 4 bytes a nie tak jak powinien 8 bytes. Aby zajmowa\u0142o 8 bytes to nalezy uruchomi\u0107 JVM z flag\u0105: ",(0,i.yg)("em",{parentName:"p"},(0,i.yg)("inlineCode",{parentName:"em"},"-XX:-UseCompressedOops"))),(0,i.yg)("p",{parentName:"li"},"Dodatkowo nale\u017cy pami\u0119ta\u0107 \u017ce 4 bytes to 32 bit\xf3w czyli 2^32 mo\u017cliwych unikalnych adres\xf3w referencji do zapisania (przy compressed oops wykorzystywane jest przesuni\u0119cie o e bity co efektywnie daje nam a\u017c 8 razy wi\u0119cej mo\u017cliwych adres\xf3w)")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"boolean i byte: 1 byte")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"short and char: 2bytes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"int and float: 4 bytes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"long and double 8 bytes"))),(0,i.yg)("h2",{id:"typy-okre\u015ble\u0144-zajmowanej-pami\u0119ci"},"Typy okre\u015ble\u0144 zajmowanej pami\u0119ci:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Shallow size - to co nam ClassLayout m\xf3wi"),(0,i.yg)("li",{parentName:"ul"},"Deep size - to co nam footprint m\xf3wi"),(0,i.yg)("li",{parentName:"ul"},"Retained size - to co zwalnia GC - np. te wielko\u015bci pokazywane s\u0105 w heapdump")),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Typy plik\xf3w",src:n(355).A,width:"904",height:"393"})),(0,i.yg)("p",null,"Na powy\u017cszym przyk\u0142adzie - Retained size to zwolniona pami\u0119\u0107 po usuni\u0119ciu referencji Triple - tylko Ai + Ci jest zwalniane a Bi jest u\u017cywane przez Pair. Te dodatkowe referencje komplikuj\u0105 retained size. Retained size jest zawsze pomi\u0119dzy shallow a deep size."),(0,i.yg)("h3",{id:"uk\u0142ad-klasy---classlayout-shallow-size"},"Uk\u0142ad klasy - ClassLayout (shallow size)"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"ClassLayout.parseClass(Basket.class).toPrintable(b1))")),(0,i.yg)("p",null,"Wszystkie obiekty przechowuj\u0105 dane typu podstawowego. Maj\u0105 sw\xf3j dodatkowy narzut pami\u0119ci (metadane). Uk\u0142ad klasy pokazuje nam ile bajt\xf3w zajmuj\u0105 headery, ile zajmuj\u0105 pola typu prostego danej klasy, ile zajmuj\u0105 referencje do innych pod obiekt\xf3w (ale nie pokazuje ile pod obiekt zajmuje pami\u0119ci). Dodatkowo pokazuje przesuni\u0119cie (np. 4 bytes external) - czyli przesuni\u0119cie do 8 bajt\xf3w"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"@Data\n@AllArgsConstructor\npublic class ExampleClass {\n    private int a;\n    private int b;\n}\n...\nExampleClass b1 = new ExampleClass(1232132, 123);\nSystem.out.println(ClassLayout.parseClass(ExampleClass.class).toPrintable(b1));\n")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"com.example.demo.ExampleClass object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 ed d3 b0 (00000001 11101101 11010011 10110000) (-1328288511)\n      4     4        (object header)                           6f 00 00 00 (01101111 00000000 00000000 00000000) (111)\n      8     4        (object header)                           78 f2 01 01 (01111000 11110010 00000001 00000001) (16904824)\n     12     4    int ExampleClass.a                            1232132\n     16     4    int ExampleClass.b                            123\n     20     4        (loss due to the next object alignment)\nInstance size: 24 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n")),(0,i.yg)("h3",{id:"metadane"},(0,i.yg)("strong",{parentName:"h3"},"Metadane:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"headery:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"flagi (0\u21924 bajt\xf3w) (mark word)- przechowuj\u0105 informacje o stanie obiektu. Mi\u0119dzy innymi shape obiektu, czyli czy jest to klasa czy tablica oraz hash code oraz ilo\u015b\u0107 przetrwa\u0144 GC do promocji do OldGeneration- 4 bajty")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"lock (4\u21928 bajt\xf3w) (mark word) - monitor, kt\xf3ry b\u0119dzie wykorzystywany do mutex\xf3w - 4 bajty"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-java"},"public class Lock {}\n...\nLock lock = new Lock();\n/*\nLock object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 00 00 00 \n      4     4        (object header)                           00 **00** 00 00\n      8     4        (object header)                           85 23 02 f8\n     12     4        (loss due to the next object alignment)\nInstance size: 16 bytes\n*/\nsynchronized (lock) {\n    System.out.println(ClassLayout.parseInstance(lock).toPrintable());\n}\n/*\nPierwszy header si\u0119 zmieni\u0142 poniewa\u017c przeliczony zosta\u0142 domy\u015blny hashCode()\nDrugi header si\u0119 zmieni\u0142 ze wzgl\u0119du na lock!\nLock object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           f0 78 12 03\n      4     4        (object header)                           00 **70** 00 00\n      8     4        (object header)                           85 23 02 f8\n     12     4        (loss due to the next object alignment)\n*/\n"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"class (8\u219212 bajt\xf3w) (klass word)- wska\u017anik do typu w naszym przypadku 4 bajty")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"size - rozmiar tablicy (warto\u015b\u0107 ta obecna jest tylko dla typ\xf3w tablicowych) - w przyk\u0142adzie powy\u017cej tego nie ma (4 byte)"))))),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Dane",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"pola klasy - reszta bajt\xf3w w naszym przyk\u0142adzie 2x4 bajty na pola int."))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"ewentualne przesuni\u0119cie do 8 bajt\xf3w (w naszym przypadku 4 bajty przesuni\u0119cia )")))),(0,i.yg)("h3",{id:"footprint-deep-size"},"Footprint (Deep size)"),(0,i.yg)("p",null,"Je\u015bli mamy jakie\u015b odniesienia do innych obiekt\xf3w w naszym analizowanym obiekcie to ClassLayout poka\u017ce tylko dodatkowe 4 bajty na referencj\u0119 (Nie we\u017amie pod uwag\u0119 zawarto\u015bci obiektu do kt\xf3rego si\u0119 odnosimy) - w takim przypadku warto wykorzysta\u0107 FootPrint kt\xf3ry poka\u017ce ile zajmuje pami\u0119ci ca\u0142y obiekt razem z obiektem wewn\u0105trz."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"@Data\n@AllArgsConstructor\npublic class ExampleClass {\n    private int a;\n    private int b;\n    private int c;\n    private InnerClass d;\n\n    @Data\n    @AllArgsConstructor\n    public static class InnerClass {\n        private int a;\n        private int b;\n    }\n}\n...\nExampleClass.InnerClass inner = new ExampleClass.InnerClass(10, 12);\nExampleClass b1 = new ExampleClass(1232132, 123,111, inner);\n\nSystem.out.println(GraphLayout.parseInstance(b1).toFootprint());\nSystem.out.println(ClassLayout.parseClass(ExampleClass.class).toPrintable(b1));\nSystem.out.println(ClassLayout.parseClass(ExampleClass.InnerClass.class).toPrintable(inner));\n")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"### FOOTPRINT\ncom.example.demo.ExampleClass@6dde5c8cd footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        32        32   com.example.demo.ExampleClass\n         1        24        24   com.example.demo.ExampleClass$InnerClass\n         2                  56   (total)\n\n### CLASSLAYOUT\ncom.example.demo.ExampleClass object internals:\n OFFSET  SIZE                                       TYPE DESCRIPTION                               VALUE\n      0     4                                            (object header)                           01 8c 5c de (00000001 10001100 01011100 11011110) (-564360191)\n      4     4                                            (object header)                           6d 00 00 00 (01101101 00000000 00000000 00000000) (109)\n      8     4                                            (object header)                           a0 f4 01 01 (10100000 11110100 00000001 00000001) (16905376)\n     12     4                                        int ExampleClass.a                            1232132\n     16     4                                        int ExampleClass.b                            123\n     20     4                                        int ExampleClass.c                            111\n     24     4   com.example.demo.ExampleClass.InnerClass ExampleClass.d                            (object)\n     28     4                                            (loss due to the next object alignment)\nInstance size: 32 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\ncom.example.demo.ExampleClass$InnerClass object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 5b 3e 5b (00000001 01011011 00111110 01011011) (1530813185)\n      4     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      8     4        (object header)                           78 f2 01 01 (01111000 11110010 00000001 00000001) (16904824)\n     12     4    int InnerClass.a                              10\n     16     4    int InnerClass.b                              12\n     20     4        (loss due to the next object alignment)\nInstance size: 24 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n")),(0,i.yg)("p",null,"Powy\u017cej mamy por\xf3wnanie Footprint i ClassLayout. W Footprint widzimy dok\u0142adnie ile bajt\xf3w zajmuje obiekt z jego podobiektami (56 bajt\xf3w). A w ClassLayout widzimy tylko przegl\u0105d danej klasy bez pod obiekt\xf3w (32 bytes i 24 bytes)."),(0,i.yg)("p",null,"Rozbijmy footprint aby jeszcze bardziej by\u0142o to zrozumia\u0142e:"),(0,i.yg)("p",null,"Na 56 bytes sk\u0142\u0105da si\u0119:\nExampleClass: 12 bajt\xf3w na metadane + 3x 4 bajty na inta + 4 bajty na referencje = 28 bajt\xf3w\n28 bajt\xf3w + 4bajt\xf3w (wyr\xf3wnanie do 8 bajt\xf3w) = ",(0,i.yg)("strong",{parentName:"p"},"32 bajt\xf3w"),"\nInnerClass: 12 bajt\xf3w na metadane + 2x 4 bajty na inta = 20 bajt\xf3w - nie jest to wielokrotno\u015b\u0107 8 bajt\xf3w (wyr\xf3wnanie) wi\u0119c: 20 bajt\xf3w + 4 bajt\xf3w = 24 bajty."),(0,i.yg)("h3",{id:"compressed-vs-uncompressed-references"},"Compressed vs Uncompressed References"),(0,i.yg)("p",null,"Dzi\u0119ki temu \u017ce jest wyr\xf3wnanie do wielokrotno\u015bci 8 byte, mo\u017cemy wykorzysta\u0107 pewn\u0105 ciekaw\u0105 w\u0142asno\u015b\u0107 jak\u0105 jest zapis takich liczb w formie binarnej. Wszystkie wielokrotno\u015bci liczby 8 w formie binarnej ko\u0144cz\u0105 si\u0119 minimum trzema zerami (z prawej strony). Znaj\u0105c t\u0105 prawid\u0142owo\u015b\u0107 programi\u015bci JVM wykorzystali t\u0105 w\u0142asno\u015b\u0107 tak \u017ce robi\u0105 przesuni\u0119cie o 3 bity w prawo co powoduje \u017ce do zapisu adres\xf3w pami\u0119ci mamy dodatkowe 3 bity. Co zwi\u0119ksza nam zakres z 2^32~4GB do 2^(32+3)~32GB. (8 razy wi\u0119cej mo\u017cliwych adres\xf3w)"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Dzi\u0119ki temu pozwalamy na wi\u0119cej ni\u017c 4 GB przestrzeni na stercie z referencjami 32-bitowymi na maszynach 64-bitowych!")),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Bit shifting",src:n(5362).A,width:"841",height:"232"})),(0,i.yg)("p",null,"Domy\u015blnie uruchomiona jest kompresja referencji. To oznacza tyle, \u017ce klass word zajmuje 4 byt\xf3w oraz ka\u017cda referencja zajmuje 4 byt\xf3w. Takie ustawienia maj\u0105 limit ",(0,i.yg)("strong",{parentName:"p"},"32 GB heapa.")," Gdy u\u017cywamy wi\u0119cej ni\u017c 32 GB heapa to automatycznie kompresja jest wy\u0142\u0105czana. Ewentualnie mo\u017cemy r\u0119cznie wy\u0142\u0105czy\u0107 kompresje referencji poprzez ",(0,i.yg)("em",{parentName:"p"},(0,i.yg)("inlineCode",{parentName:"em"},"-XX:-UseCompressedOops"),"- gdzie takie ustawienie wy\u0142\u0105cza kompresowanie referencji i wtedy rozmiar referencji wynosi 8 byt\xf3w.")),(0,i.yg)("h3",{id:"powy\u017cej-32-gb"},"Powy\u017cej 32 GB"),(0,i.yg)("p",null,"Je\u015bli chcemy u\u017cy\u0107 wi\u0119cej ni\u017c 32 GB heapa i chcemy u\u017cywa\u0107 compressed reference:"),(0,i.yg)("p",null,"Wz\xf3r na maxymalny heap size: 4GB * ObjectAlignmentInBytes. - ale nale\u017cy pami\u0119ta\u0107, \u017ce allignments wzrasta dla ka\u017cdego istniej\u0105cego obiektu co w konsekwencji zwi\u0119ksza rozmiar ka\u017cdego obiektu. Nie zawsze si\u0119 to op\u0142aci."),(0,i.yg)("h3",{id:"co-to-jest-paddingalligment-gap-internal-space-losses"},"Co to jest padding/alligment gap (internal space losses)"),(0,i.yg)("p",null,"Dope\u0142nienie bajt\xf3w do wielokrotno\u015bci 8 bajt\xf3w mo\u017ce przyj\u0105\u0107 2 formy"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"internal space losses"),(0,i.yg)("li",{parentName:"ul"},"external space losses")),(0,i.yg)("p",null,"Procesor pobiera dane po 8 byt\xf3w naraz. Aby u\u0142atwi\u0107 pobieranie danych robimy przesuni\u0119cia. Przyk\u0142ad u\u0142atwienia pobierania danych z internal space losses - dla \u0142atwiejszego ukazania przyk\u0142adu wykorzystano flag\u0119 JVM ",(0,i.yg)("em",{parentName:"p"},(0,i.yg)("inlineCode",{parentName:"em"},"-XX:ObjectAlignmentInBytes=16")),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"SimpleLong object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0    12        (object header)                           N/A\n     12     4        (alignment/padding gap)                  \n     16     8   long SimpleLong.state                          N/A\n     24     8        (loss due to the next object alignment)\nInstance size: 32 bytes\nSpace losses: 4 bytes internal + 8 bytes external = 12 bytes total\n")),(0,i.yg)("p",null,"Po 12 bajtach zwi\u0105zanych z headerem dodany zosta\u0142 internal aligment/padding gap = 4 bajty. tak aby wyci\u0105ganie longa by\u0142o w jednym procesie CPU. (tak aby long variable by\u0142o w offsecie 16)"),(0,i.yg)("h3",{id:"field-packing---upakowanie-p\xf3l"},"Field Packing - Upakowanie p\xf3l"),(0,i.yg)("p",null,"O kolejno\u015bci upakowania p\xf3l w pami\u0119ci decyduje JVM a nie deklaracja p\xf3l w implementacji klasy. Jest to po to aby w\u0142a\u015bnie u\u0142atwi\u0107 kondensowanie wielokrotno\u015bci 8 bajt\xf3w tak aby np. int nie by\u0142 rozdzielony na 2 wyci\u0105gni\u0119cia danych po 8 bajt\xf3w."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"public class FieldsArrangement {\n    private boolean first;\n    private char second;\n    private double third;\n    private int fourth;\n    private boolean fifth;\n}\n...\nOFFSET  SIZE      TYPE DESCRIPTION                               VALUE\n      0    12           (object header)                           N/A\n     12     4       int FieldsArrangement.fourth                  N/A\n     16     8    double FieldsArrangement.third                   N/A\n     24     2      char FieldsArrangement.second                  N/A\n     26     1   boolean FieldsArrangement.first                   N/A\n     27     1   boolean FieldsArrangement.fifth                   N/A\n     28     4           (loss due to the next object alignment)\n")),(0,i.yg)("hr",null),(0,i.yg)("h2",{id:"inne-przyk\u0142ady---sprawdzanie-rozmiaru-pami\u0119ci-dla-obiekt\xf3w"},"Inne przyk\u0142ady - Sprawdzanie rozmiaru pami\u0119ci dla obiekt\xf3w"),(0,i.yg)("h3",{id:"array"},"Array:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Array boolean\xf3w"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-java"},"boolean[] booleans = new boolean[3];\nSystem.out.println(ClassLayout.parseInstance(booleans).toPrintable());\nSystem.out.println(GraphLayout.parseInstance(booleans).toFootprint());\n/* Output\n[Z object internals:\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4           (object header)                           00 1b 00 00 (00000000 00011011 00000000 00000000) (6912)\n     12     4           (object header)                           03 00 00 00 (00000011 00000000 00000000 00000000) (3)\n     16     3   boolean [Z.<elements>                             N/A\n     19     5           (loss due to the next object alignment)\nInstance size: 24 bytes\nSpace losses: 0 bytes internal + 5 bytes external = 5 bytes total\n\n[Z@1068e947d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        24        24   [Z\n         1                  24   (total)\n*/\n"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Array int\xf3w"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-java"},"int[] ints = new int[4];\nSystem.out.println(ClassLayout.parseInstance(ints).toPrintable());\nSystem.out.println(GraphLayout.parseInstance(ints).toFootprint());\n/* Output\n[I object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)                           a0 26 00 00 (10100000 00100110 00000000 00000000) (9888)\n     12     4        (object header)                           04 00 00 00 (00000100 00000000 00000000 00000000) (4)\n     16    16    int [I.<elements>                             N/A\nInstance size: 32 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n\n[I@5f71c76ad footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        32        32   [I\n         1                  32   (total)\n*/\n")))),(0,i.yg)("h3",{id:"pami\u0119\u0107-dla-arraylisty"},"Pami\u0119\u0107 dla ArrayListy:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"ArrayList<Integer> integers = new ArrayList<>();\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\n/*\njava.util.ArrayList@185a6e9d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        16        16   [Ljava.lang.Object;\n         1        24        24   java.util.ArrayList\n         2                  40   (total)\n*/\nfor(int i=0; i<100000; i++){\n            integers.add(i);\n}\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\n\n//output:\n/*\njava.util.ArrayList@185a6e9d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1    426856    426856   [Ljava.lang.Object;\n    100000        16   1600000   java.lang.Integer\n         1        24        24   java.util.ArrayList\n    100002             2026880   (total)\n*/\n")),(0,i.yg)("p",null,"2 026 880 bytes = 2mb 27kb dla 100 000 int\xf3w. (100 000 * 4=400 000 bytes.)\nGdy zainicjalizujemy initial capacity ArrayListy to warto\u015b\u0107 pami\u0119ci jest mniejsza o 26880 bytes (26kb)"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-java"},"ArrayList<Integer> integers = new ArrayList<>(100000);\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\n/*\njava.util.ArrayList@179ece50d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1    400016    400016   [Ljava.lang.Object;\n         1        24        24   java.util.ArrayList\n         2              400040   (total)\n*/\nfor(int i=0; i<100000; i++){\n            integers.add(i);\n}\nSystem.out.println(GraphLayout.parseInstance(integers).toFootprint());\n/*\njava.util.ArrayList@179ece50d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1    400016    400016   [Ljava.lang.Object;\n    100000        16   1600000   java.lang.Integer\n         1        24        24   java.util.ArrayList\n    100002             2000040   (total)\n*/\n")),(0,i.yg)("h3",{id:"boolean---przyk\u0142ad-uk\u0142adu-pami\u0119ci-klasy-os\u0142onowej"},"Boolean - Przyk\u0142ad uk\u0142adu pami\u0119ci klasy os\u0142onowej"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Boolean 16 bytes - szczeg\xf3\u0142y uk\u0142adu pami\u0119ci poni\u017cej:"),(0,i.yg)("p",{parentName:"li"},"Wywo\u0142ujemy lini\u0119 kodu: ",(0,i.yg)("inlineCode",{parentName:"p"},"System.*out*.println(ClassLayout.*parseClass*(Boolean.class).toPrintable());")),(0,i.yg)("p",{parentName:"li"},"Output:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},"# WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf\n# WARNING: Unable to attach Serviceability Agent. sun.jvm.hotspot.memory.Universe.getNarrowOopBase()\njava.lang.Boolean object internals:\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\n      0    12           (object header)                           N/A\n     12     1   boolean Boolean.value                             N/A\n     13     3           (loss due to the next object alignment)\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 3 bytes external = 3 bytes total\n")),(0,i.yg)("p",{parentName:"li"},"Warto\u015b\u0107 danych zajmuje 1 byte (8 bit\xf3w) a nie 1 bit jakby mog\u0142o si\u0119 wydawa\u0107.\n12 bytes na metadane + 1 byte na dane booleana + 3 bytes przesuni\u0119cia (aby by\u0142a wielokrotno\u015b\u0107 8)=16byt\xf3w"))),(0,i.yg)("h3",{id:"string---obliczanie-pami\u0119ci-zajmowanej-przez-string---jol--footprint"},"String - ",(0,i.yg)("a",{parentName:"h3",href:"/pl/blog/string-in-jvm-memory"},"Obliczanie pami\u0119ci zajmowanej przez String - JOL  Footprint")))}c.isMDXComponent=!0},5362:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/bit-shifting-68ac0bba76cdaf64ccf1111856163eca.png"},355:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/size-types-0b6e945e9f03b350461559386c49bd83.png"}}]);