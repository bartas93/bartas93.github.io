"use strict";(self.webpackChunkbj_blog=self.webpackChunkbj_blog||[]).push([[7543],{5512:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>y});var a=n(8168),r=(n(6540),n(5680));const i={slug:"string-in-jvm-memory",title:"Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint",authors:"bjab",tags:["jvm","jol","string","heap","memory"]},o="Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint",l={permalink:"/pl/blog/string-in-jvm-memory",source:"@site/i18n/pl/docusaurus-plugin-content-blog/2024-05-16-String-memory-usage-jvm.md",title:"Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint",description:"W skr\xf3cie:",date:"2024-05-16T00:00:00.000Z",formattedDate:"16 maja 2024",tags:[{label:"jvm",permalink:"/pl/blog/tags/jvm"},{label:"jol",permalink:"/pl/blog/tags/jol"},{label:"string",permalink:"/pl/blog/tags/string"},{label:"heap",permalink:"/pl/blog/tags/heap"},{label:"memory",permalink:"/pl/blog/tags/memory"}],readingTime:6.27,hasTruncateMarker:!0,authors:[{name:"Bartek Jab\u0142o\u0144ski",title:"Backend Cloud Developer",url:"https://bartas93.github.io",imageURL:"/images/bartek_jablonski_2.png",key:"bjab"}],frontMatter:{slug:"string-in-jvm-memory",title:"Obliczanie pami\u0119ci zajmowanej przez String - JOL Footprint",authors:"bjab",tags:["jvm","jol","string","heap","memory"]},prevItem:{title:"Wyra\u017cenia regularne",permalink:"/pl/blog/regular-expressions"},nextItem:{title:"\u015aci\u0105gaj Playlisty z YouTube bez reklam za darmo - za pomoc\u0105 prostego skryptu",permalink:"/pl/blog/python-youtube-downloader"}},s={authorsImageUrls:[void 0]},y=[{value:"W skr\xf3cie:",id:"w-skr\xf3cie",level:2},{value:"JOL - String",id:"jol---string",level:2}],c={toc:y},b="wrapper";function p(e){let{components:t,...n}=e;return(0,r.yg)(b,(0,a.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"w-skr\xf3cie"},"W skr\xf3cie:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Na pami\u0119\u0107 obiektu String sk\u0142ada si\u0119 24 byte na metadane + ilo\u015b\u0107 znak\xf3w razy 1 byte lub 2 byte w zale\u017cno\u015bci od warto\u015bci coder",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Metadane : mark word x2 (4 bytes x2 = 8 bytes), klass word (4 bytes), referencja do tablicy byte[] lub char[] (4 byte), hash (4 byte), hashIsZero (1 byte), coder (1 byte),  padding (2 byte)"))),(0,r.yg)("li",{parentName:"ul"},"Obiekt String ma 2 dodatkowe flagi:",(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"- gdy `coder =1` to kodowanie UTF-16 (2 bytes na znak)\n- gdy `coder = 0` to kodowanie LATIN-1 (1 byte na znak)\n- hashIsZero jest to flaga kt\xf3ra m\xf3wi czy obliczenie hasha zosta\u0142o ju\u017c wykonane\n")))),(0,r.yg)("h2",{id:"jol---string"},"JOL - String"),(0,r.yg)("p",null,"Od Java 9 u\u017cywamy Compact String czyli je\u015bli to mo\u017cliwe to u\u017cywamy kodowania LATIN-1 a jak nie to ustawiany jest coder=1 i u\u017cywamy UTF-16."),(0,r.yg)("p",null,"(Przed Java 9 wszystko sprowadza\u0142o si\u0119 do char[] i ka\u017cda literka by\u0142a r\xf3wna 2 byte Utf-16.)"),(0,r.yg)("p",null,"Je\u015bli chocia\u017c jeden znak b\u0119dzie inny ni\u017c latin-1 (1 byte) to ka\u017cdy znak w Stringu jest kodowany w utf16 (2 byte)."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},'String utf16String = "Bartosz Jab\u0142o\u0144ski"; // 17 znak\xf3w x 2 bytes = 34 bytes\nSystem.out.println(ClassLayout.parseInstance(utf16String).toPrintable());\nSystem.out.println(GraphLayout.parseInstance(utf16String).toFootprint());\nSystem.out.println(ClassLayout.parseInstance(utf16String.getBytes()).toPrintable());\nSystem.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());\n       \nString latin1String = "Bartosz Jablonski"; // 17 znak\xf3w x 1 bytes = 17 bytes\nSystem.out.println(ClassLayout.parseInstance(latin1String).toPrintable());\nSystem.out.println(GraphLayout.parseInstance(latin1String).toFootprint());\nSystem.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());\nSystem.out.println(ClassLayout.parseInstance(latin1String.toCharArray()).toPrintable());\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"#### Bartosz Jab\u0142o\u0144ski - UTF-16 - coder:1\njava.lang.String object internals:\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\n     12     4       int String.hash                               0\n     16     1      byte String.coder                              1\n     17     1   boolean String.hashIsZero                         false\n     18     2           (alignment/padding gap)                  \n     20     4    byte[] String.value                              [66, 0, 97, 0, 114, 0, 116, 0, 111, 0, 115, 0, 122, 0, 32, 0, 74, 0, 97, 0, 98, 0, 66, 1, 111, 0, 68, 1, 115, 0, 107, 0, 105, 0]\nInstance size: 24 bytes\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\n\njava.lang.String@7dc222aed footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        56        56   [B\n         1        24        24   java.lang.String\n         2                  80   (total)\n\n[B object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\n     12     4        (object header)                           13 00 00 00 (00010011 00000000 00000000 00000000) (19)\n     16    19   byte [B.<elements>                             N/A\n     35     5        (loss due to the next object alignment)\nInstance size: 40 bytes\nSpace losses: 0 bytes internal + 5 bytes external = 5 bytes total\n\n[C object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\n     16    34   char [C.<elements>                             N/A\n     50     6        (loss due to the next object alignment)\nInstance size: 56 bytes\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\n")),(0,r.yg)("p",null,"W pierwszym przypadku dla ",(0,r.yg)("inlineCode",{parentName:"p"},"Bartosz Jab\u0142o\u0144ski")," gdzie zawarli\u015bmy polskie znaki niezawieraj\u0105ce si\u0119 w LATIN-1 wida\u0107, \u017ce String ma flag\u0119 ",(0,r.yg)("inlineCode",{parentName:"p"},"coder")," ustawion\u0105 na ",(0,r.yg)("inlineCode",{parentName:"p"},"1")," czyli u\u017cywa kodowania typu ",(0,r.yg)("inlineCode",{parentName:"p"},"UTF-16")," (2 byte per znak)."),(0,r.yg)("p",null,"Footprint pokazuje deep size obiektu String (17 znakowy) wynosi 80 bytes. Na to sk\u0142ada si\u0119 String i jego metadane i pod obiekt Stringa czyli tablica char[] w kodowaniu UTF-16 (2byte per znak).\nPodsumowuj\u0105c:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"24 bytes - String z referencj\u0105 zajmuje 24 bytes (12 bytes na metadane (headery) + 4 bytes na hash(int) + 1 byte na coder, + 1 byte na hashIsZero + 4 bytes referencji do tablicy char\xf3w  + 2 byte na alligment padding).",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Gdzie coder odpowiada za:")))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"    Jest to warto\u015b\u0107 zwi\u0105zana \u015bci\u015ble z implementacj\u0105 JVM (hotspot). Jest to identyfikator kodowania u\u017cywany do kodowania bajt\xf3w. Obs\u0142ugiwane warto\u015bci to LATIN1 (coder=0) i UTF16(coder=1).\n    Je\u015bli chocia\u017c jedna literka **nie zawiera si\u0119 w LATIN1** to coder=1 i ca\u0142y String b\u0119dzie kodowany do UTF-16 czyli w pami\u0119ci zajmie (n literek * 2 bytes).\n    \n- Gdzie hashIsZero odpowiada za:\n    \n    \n    To pole m\xf3wi JVM czy mo\u017cna omin\u0105\u0107 ponownemu obliczaniu hashu. (taki rodzaj cachu)\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"56 bytes - Tablica byte[] zajmuje 56 bytes na co sk\u0142ada si\u0119: 12 byte metadanych (header\xf3w) + 4 byte metadane dotycz\u0105ce tablicy (length) + dane 17 znak\xf3w * 2 byte (34 byte) = 50 byte + 6 byt\xf3w na wyr\xf3wnanie. Obrazuje to nieintuicyjnie linia kodu: ",(0,r.yg)("inlineCode",{parentName:"li"},"System.out.println(ClassLayout.parseInstance(utf16String.toCharArray()).toPrintable());"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-java"},"#### Bartosz Jablonski - LATIN-1 - coder:0\njava.lang.String object internals:\n OFFSET  SIZE      TYPE DESCRIPTION                               VALUE\n      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4           (object header)                           d8 e8 00 00 (11011000 11101000 00000000 00000000) (59608)\n     12     4       int String.hash                               0\n     16     1      byte String.coder                              0\n     17     1   boolean String.hashIsZero                         false\n     18     2           (alignment/padding gap)                  \n     20     4    byte[] String.value                              [66, 97, 114, 116, 111, 115, 122, 32, 74, 97, 98, 108, 111, 110, 115, 107, 105]\nInstance size: 24 bytes\nSpace losses: 2 bytes internal + 0 bytes external = 2 bytes total\n\njava.lang.String@48a242ced footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         1        40        40   [B\n         1        24        24   java.lang.String\n         2                  64   (total)\n\n[B object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)                           c0 22 00 00 (11000000 00100010 00000000 00000000) (8896)\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\n     16    17   byte [B.<elements>                             N/A\n     33     7        (loss due to the next object alignment)\nInstance size: 40 bytes\nSpace losses: 0 bytes internal + 7 bytes external = 7 bytes total\n\n[C object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)                           f0 1c 00 00 (11110000 00011100 00000000 00000000) (7408)\n     12     4        (object header)                           11 00 00 00 (00010001 00000000 00000000 00000000) (17)\n     16    34   char [C.<elements>                             N/A\n     50     6        (loss due to the next object alignment)\nInstance size: 56 bytes\nSpace losses: 0 bytes internal + 6 bytes external = 6 bytes total\n")),(0,r.yg)("p",null,"W drugim przypadku dla ",(0,r.yg)("inlineCode",{parentName:"p"},"Bartosz Jablonski")," gdzie nie zawarli\u015bmy polskich znak\xf3w, wida\u0107, \u017ce String ma flag\u0119 coder ustawion\u0105 na 0 czyli u\u017cywa kodowania typu LATIN-1 (1 byte per znak)."),(0,r.yg)("p",null,"Footprint pokazuje deep size obiektu String (17 znakowy) wynosi 64 bytes. Na to sk\u0142ada si\u0119 String i jego metadane i pod obiekt Stringa czyli tablica byte[] w kodowaniu LATIN-1 (1 byte per znak) ."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"String z referencj\u0105 zajmuje 24 bytes (12 bytes na metadane (headery) + 4 bytes na hash(int) + 1 byte na coder + 1 byte na hashIsZero + 4 bytes referencji do tablicy byt\xf3w + 2 byte na alligment padding)."),(0,r.yg)("li",{parentName:"ul"},"Tablica byte[] zajmuje 40 bytes na co sk\u0142ada si\u0119: 12 byte metadanych (header\xf3w) + 4 byte metadane dotycz\u0105ce tablicy (length) + dane 17 znak\xf3w * 1 byte (17 byte) = 33 byte + 7 byt\xf3w na wyr\xf3wnanie.")),(0,r.yg)("p",null,"Obrazuje to linia kodu: ",(0,r.yg)("inlineCode",{parentName:"p"},"System.out.println(ClassLayout.parseInstance(latin1String.getBytes()).toPrintable());")),(0,r.yg)("p",null,"Dzi\u0119ki fladze ",(0,r.yg)("inlineCode",{parentName:"p"},"coder")," i braku znak\xf3w specjalnych mamy zysk w mniejszej ilo\u015bci zajmowanej pami\u0119ci r\xf3wny 16 byt\xf3w - co dzieje si\u0119 bez naszej ingerencji programistycznej."))}p.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>d});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),y=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=y(e.components);return a.createElement(s.Provider,{value:t},e.children)},b="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=y(n),g=r,d=b["".concat(s,".").concat(g)]||b[g]||p[g]||i;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[b]="string"==typeof e?e:r,o[1]=l;for(var y=2;y<i;y++)o[y]=n[y];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"}}]);